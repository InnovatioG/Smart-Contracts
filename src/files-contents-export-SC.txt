====== Folder Tree ======

├── Campaign
│   ├── Funds
│   │   ├── OnChain.hs
│   │   └── Types.hs
│   ├── Helpers.hs
│   ├── OnChain.hs
│   └── Types.hs
├── Constants.hs
├── Deploy.hs
├── Others
│   ├── PolicyFT.hs
│   └── PolicyNFT.hs
├── Protocol
│   ├── Helpers.hs
│   ├── OnChain.hs
│   └── Types.hs
├── Script
│   ├── OnChain.hs
│   └── Types.hs
└── Types.hs

====== File contents ======


====== Campaign/Funds/OnChain.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

----------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
{- HLINT ignore "Reduce duplication"          -}
----------------------------------------------------------------------------2

module Campaign.Funds.OnChain where

----------------------------------------------------------------------------2
-- Import Externos
----------------------------------------------------------------------------2

import qualified Ledger
import qualified Ledger.Ada                as LedgerADA
import qualified Ledger.Ada                as LedgerAda
import qualified Ledger.Value              as LedgerValue
import qualified Plutonomy
import qualified Plutus.V2.Ledger.Api      as LedgerApiV2
import qualified Plutus.V2.Ledger.Contexts as LedgerContextsV2
import qualified PlutusTx
import           PlutusTx.Prelude

----------------------------------------------------------------------------2
-- Import Internos
----------------------------------------------------------------------------2

import qualified Campaign.Funds.Types      as T
import qualified Campaign.Helpers          as CampaignHelpers
import qualified Campaign.Types            as CampaignT
import qualified Constants                 as T
import qualified Helpers.OnChain           as OnChainHelpers
import           Prelude                   (Show)
import qualified Protocol.Types            as ProtocolT
import qualified Types                     as T

----------------------------------------------------------------------------2
-- Modulo
----------------------------------------------------------------------------2

--------------------------------------------------------------------------------
-- Validator Types and Context
--------------------------------------------------------------------------------

data ValidationParams
    = ValidationParams
          { vParams                   :: !T.ValidatorParams
          , vCtx                      :: !LedgerContextsV2.ScriptContext
          , vInfo                     :: !LedgerContextsV2.TxInfo
          , vRedeemer                 :: !T.ValidatorRedeemer
          , vDatum                    :: !T.CampaignFundsDatumType
          , vOwnInput                 :: !LedgerContextsV2.TxOut
          , vOwnAddress               :: !LedgerApiV2.Address
          , vInputValue               :: !Ledger.Value
          , vCampaignID_AC            :: !LedgerValue.AssetClass
          , vProtocolID_AC            :: !LedgerValue.AssetClass
          , vCampaignFundsID_AC       :: !LedgerValue.AssetClass
          , vCampaignFundsPolicyID_CS :: !LedgerApiV2.CurrencySymbol
          , vOwnInputs                :: ![LedgerContextsV2.TxOut]
          , vOwnOutputs               :: ![LedgerContextsV2.TxOut]
          , vInputsLength             :: !Integer
          , vOutputsLength            :: !Integer
          , vCampaignDatum            :: !CampaignT.CampaignDatumType
          }
    deriving (Show)

{-# INLINEABLE mkValidator #-}
mkValidator :: T.ValidatorParams -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkValidator !params !datumRaw !redRaw !ctxRaw =
    let !vp = mkValidationParams params datumRaw redRaw ctxRaw
    in if traceIfFalse "not unique" (checkUnique vp)
          && validate vp
       then ()
       else error ()

{-# INLINEABLE mkValidationParams #-}
mkValidationParams :: T.ValidatorParams -> BuiltinData -> BuiltinData -> BuiltinData -> ValidationParams
mkValidationParams !params !datumRaw !redRaw !ctxRaw =
    let !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.ValidatorRedeemer redRaw
        !datum = T.getCampaignFunds_DatumType $ LedgerApiV2.unsafeFromBuiltinData @T.ValidatorDatum datumRaw
        !ownInput = OnChainHelpers.getUnsafe_Own_Input_TxOut ctx
        !address = LedgerApiV2.txOutAddress ownInput
        !campaignPolicy_CS = T.cfdCampaignPolicy_CS datum
        !campaignFundsPolicyID_CS = T.cfdCampaignFundsPolicyID_CS datum
        !protocolPolicyID_CS = T.vpProtocolPolicyID_CS params
        !ownInputs = getOwnInputs info address
        !ownOutputs = getOwnOutputs info address
        !useNormalInput = case redeemer of
            T.ValidatorRedeemerDelete _  -> True
            T.ValidatorRedeemerCollect _ -> True
            T.ValidatorRedeemerMerge _   -> True
            _                            -> False
        !campaignDatum = getCampaign_Datum ctx (LedgerValue.AssetClass (campaignPolicy_CS, T.campaignID_TN)) useNormalInput
        !campaignFunds_Index = T.cfdIndex datum
        !campaignFundsID_TN = LedgerApiV2.TokenName $ T.campaignFundsID_TN_basename <> OnChainHelpers.intToBBS campaignFunds_Index
    in ValidationParams
        { vParams = params
        , vCtx = ctx
        , vInfo = info
        , vRedeemer = redeemer
        , vDatum = datum
        , vOwnInput = ownInput
        , vOwnAddress = address
        , vInputValue = LedgerApiV2.txOutValue ownInput
        , vCampaignID_AC = LedgerValue.AssetClass (campaignPolicy_CS, T.campaignID_TN)
        , vProtocolID_AC = LedgerValue.AssetClass (protocolPolicyID_CS, T.protocolID_TN)
        , vCampaignFundsID_AC = LedgerValue.AssetClass (campaignFundsPolicyID_CS, campaignFundsID_TN)
        , vCampaignFundsPolicyID_CS = campaignFundsPolicyID_CS
        , vOwnInputs = ownInputs
        , vOwnOutputs = ownOutputs
        , vInputsLength = length ownInputs
        , vOutputsLength = length ownOutputs
        , vCampaignDatum = campaignDatum
        }

--------------------------------------------------------------------------------
-- Primary Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validate #-}
validate :: ValidationParams -> Bool
validate !vp = case vRedeemer vp of
    T.ValidatorRedeemerEmergency _ -> validateEmergency vp
    _                              -> validateNonEmergency vp

{-# INLINEABLE validateEmergency #-}
validateEmergency :: ValidationParams -> Bool
validateEmergency !vp =
    let !tokenEmergencyAdmin_AC = LedgerValue.AssetClass (T.vpTokenEmergencyAdminPolicy_CS $ vParams vp, T.tokenEmergencyAdmin_TN)
        !outputs = LedgerApiV2.txInfoOutputs $ vInfo vp
    in traceIfFalse "not isEmergencyAdminTokenPresent" $
       not (null outputs) && OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue $ head outputs) tokenEmergencyAdmin_AC

{-# INLINEABLE validateNonEmergency #-}
validateNonEmergency :: ValidationParams -> Bool
validateNonEmergency !vp =
    traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange (vInfo vp) T.validTxTimeRange)
        && validateByInputOutput vp

--------------------------------------------------------------------------------
-- Input/Output Processing
--------------------------------------------------------------------------------

{-# INLINEABLE validateByInputOutput #-}
validateByInputOutput :: ValidationParams -> Bool
validateByInputOutput !vp = case vRedeemer vp of
    T.ValidatorRedeemerDelete _        -> validateInputsNoOutput vp
    T.ValidatorRedeemerBalanceAssets _ -> validateManyInputsSameOutputs vp
    _                                  -> validateInputsOneOutput vp

{-# INLINEABLE validateInputsNoOutput #-}
validateInputsNoOutput :: ValidationParams -> Bool
validateInputsNoOutput !vp =
    traceIfFalse "not null outputs_Own_txOuts" (vOutputsLength vp == 0)
        && validateDelete vp

{-# INLINEABLE validateManyInputsSameOutputs #-}
validateManyInputsSameOutputs :: ValidationParams -> Bool
validateManyInputsSameOutputs !vp =
    traceIfFalse "not isSameOutputsAsInputs" (vInputsLength vp == vOutputsLength vp)
        && traceIfFalse "not length inputs_Own_TxOuts > 1" (vInputsLength vp > 1)
        && validateBalance vp

{-# INLINEABLE validateInputsOneOutput #-}
validateInputsOneOutput :: ValidationParams -> Bool
validateInputsOneOutput !vp =
    case getOutput_CampaignFunds_DatumAndValue vp of
        Nothing -> traceError "Expected CampaignFunds output"
        Just (!outDatum, !outValue) ->
            if vInputsLength vp == 1
                then validateSingleInputRedeemer vp outDatum outValue
                else validateMultipleInputsRedeemer vp outDatum outValue

{-# INLINEABLE validateSingleInputRedeemer #-}
validateSingleInputRedeemer :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> Bool
validateSingleInputRedeemer !vp !outDatum !outValue = case vRedeemer vp of
    T.ValidatorRedeemerUpdateMinADA _ -> validateMinADAUpdate vp outDatum outValue
    T.ValidatorRedeemerDeposit r      -> validateDeposit vp outDatum outValue r
    T.ValidatorRedeemerWithdraw r     -> validateWithdraw vp outDatum outValue r
    T.ValidatorRedeemerCollect r      -> validateCollect vp outDatum outValue r
    T.ValidatorRedeemerSell r         -> validateSell vp outDatum outValue r
    T.ValidatorRedeemerGetBack r      -> validateGetBack vp outDatum outValue r
    _                                 -> False

{-# INLINEABLE validateMultipleInputsRedeemer #-}
validateMultipleInputsRedeemer :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> Bool
validateMultipleInputsRedeemer !vp !outDatum !outValue = case vRedeemer vp of
    T.ValidatorRedeemerMerge _ -> validateMerge vp outDatum outValue
    _                          -> False


--------------------------------------------------------------------------------
-- MinADA Update Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateMinADAUpdate #-}
validateMinADAUpdate :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> Bool
validateMinADAUpdate !vp !outDatum !outValue =
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Campaign Admin
    -- Que el CampaignFundsDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignFundsDatum se actualiza correctamente
    -- Que el CampaignFundsDatum value cambie con el min ADA nuevo
    -- no hay restricciones temporales
    ------------------
    validateProtocolOrCampaignAdmin vp
        && traceIfFalse "not min ADA > 0" (T.cfdMinADA outDatum > 0)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_UpdatedMinADA"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
            CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_MinADAChanged (vDatum vp) newMinADA)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_ChangedADA"
            (outValue `OnChainHelpers.isEqValue` (vInputValue vp <> LedgerAda.lovelaceValueOf adaChange))
     where
        !newMinADA = T.cfdMinADA outDatum
        !adaChange = newMinADA - T.cfdMinADA (vDatum vp)

--------------------------------------------------------------------------------
-- Deposit Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateDeposit #-}
validateDeposit :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> T.ValidatorRedeemerDepositType -> Bool
validateDeposit !vp !outDatum !outValue (T.ValidatorRedeemerDepositType !amount) =
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol or Campaign Admin
    -- Que el CampaignFundsDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignFundsDatum se actualiza correctamente con nuevos depositos
    -- Que el CampaignFundsDatum value cambie con los tokens depositados
    -- Que el CampaignDatum este en estado CsCreated
    ------------------
    validateProtocolOrCampaignAdmin vp
        && traceIfFalse "not isCampaignStatus CsCreated"
            (isCampaignStatus vp CampaignT.CsCreated)
        && traceIfFalse "not amount > 0"
            (amount > 0)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Updated_With_Deposits"
            (validateDepositDatumUpdate vp outDatum amount)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_Changed_With_Deposits"
            (validateDepositValueChange vp outValue amount)

{-# INLINEABLE validateDepositDatumUpdate #-}
validateDepositDatumUpdate :: ValidationParams -> T.CampaignFundsDatumType -> Integer -> Bool
validateDepositDatumUpdate !vp !outDatum !amount =
    let !campaignFundsDatum_Out_Control = CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_Deposits
            (vDatum vp)
            amount
    in outDatum `OnChainHelpers.isUnsafeEqDatums` campaignFundsDatum_Out_Control

{-# INLINEABLE validateDepositValueChange #-}
validateDepositValueChange :: ValidationParams -> Ledger.Value -> Integer -> Bool
validateDepositValueChange !vp !outValue !amount =
    let !campaignToken_AC = getCampaignToken_AC vp
        !valueOf_CampaignToken = LedgerValue.assetClassValue campaignToken_AC amount
        !valueFor_Control = vInputValue vp <> valueOf_CampaignToken
    in outValue `OnChainHelpers.isEqValue` valueFor_Control

--------------------------------------------------------------------------------
-- Withdraw Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateWithdraw #-}
validateWithdraw :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> T.ValidatorRedeemerWithdrawType -> Bool
validateWithdraw !vp !outDatum !outValue (T.ValidatorRedeemerWithdrawType !amount) =
     ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol or Campaign Admin
    -- Que el CampaignFundsDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignFundsDatum se actualiza correctamente con nuevos withdraw
    -- Que el CampaignFundsDatum value cambie con los tokens withdraw
    -- Que el CampaignDatum este en estado CsCreated
    ------------------
    validateProtocolOrCampaignAdmin vp
        && traceIfFalse "not isCampaignStatus CsCreated"
            (isCampaignStatus vp CampaignT.CsCreated)
        && traceIfFalse "not amount > 0"
            (amount > 0)
        && traceIfFalse "not avalaible_CampaignToken >= amount"
            (T.cfdSubtotal_Avalaible_CampaignToken (vDatum vp) >= amount)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Updated_With_Withdraw"
            (validateWithdrawDatumUpdate vp outDatum amount)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_Changed_With_Withdraw"
            (validateWithdrawValueChange vp outValue amount)

{-# INLINEABLE validateWithdrawDatumUpdate #-}
validateWithdrawDatumUpdate :: ValidationParams -> T.CampaignFundsDatumType -> Integer -> Bool
validateWithdrawDatumUpdate !vp !outDatum !amount =
    let !campaignFundsDatum_Out_Control = CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_Withdraw
            (vDatum vp)
            amount
    in outDatum `OnChainHelpers.isUnsafeEqDatums` campaignFundsDatum_Out_Control

{-# INLINEABLE validateWithdrawValueChange #-}
validateWithdrawValueChange :: ValidationParams -> Ledger.Value -> Integer -> Bool
validateWithdrawValueChange !vp !outValue !amount =
    let !campaignToken_AC = getCampaignToken_AC vp
        !valueOf_CampaignToken = LedgerValue.assetClassValue campaignToken_AC amount
        !valueFor_Control = vInputValue vp <> negate valueOf_CampaignToken
    in outValue `OnChainHelpers.isEqValue` valueFor_Control

--------------------------------------------------------------------------------
-- Sell Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateSell #-}
validateSell :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> T.ValidatorRedeemerSellType -> Bool
validateSell !vp !outDatum !outValue (T.ValidatorRedeemerSellType !amount_CampaignToken) =
    ---------------------
    -- it runs alone
    ---------------------
    -- Que el CampaignFundsDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignFundsDatum se actualiza correctamente con nuevos vendidos
    -- Que el CampaignFundsDatum value cambie con el nuevo ADA y menos los tokens vendidos
    -- Que el CampaignDatum este en estado CsInitialized
    -- Que la fecha sea entre Begin y Deadline
    ------------------
    traceIfFalse "not isCampaignOpen"
        (isCampaignOpen vp)
        && traceIfFalse "not isCampaignStatus CsInitialized"
            (isCampaignStatus vp CampaignT.CsInitialized)
        && traceIfFalse "not amount_CampaignToken > 0"
            (amount_CampaignToken > 0)
        && traceIfFalse "not avalaible_CampaignToken >= amount_CampaignToken"
            (T.cfdSubtotal_Avalaible_CampaignToken (vDatum vp) >= amount_CampaignToken)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Updated_With_SoldTokens"
            (validateSellDatumUpdate vp outDatum amount_CampaignToken amount_ADA)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_Changed_WithSoldTokens"
            (validateSellValueChange vp outValue amount_CampaignToken amount_ADA)
    where
        !amount_ADA = amount_CampaignToken * CampaignT.cdCampaignToken_PriceADA (vCampaignDatum vp)
{-# INLINEABLE validateSellDatumUpdate #-}
validateSellDatumUpdate :: ValidationParams -> T.CampaignFundsDatumType -> Integer -> Integer -> Bool
validateSellDatumUpdate !vp !outDatum !amount_CampaignToken !amount_ADA =
    let 
        !campaignFundsDatum_Out_Control = CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_SoldTokens
            (vDatum vp)
            amount_CampaignToken
            amount_ADA
    in outDatum `OnChainHelpers.isUnsafeEqDatums` campaignFundsDatum_Out_Control

{-# INLINEABLE validateSellValueChange #-}
validateSellValueChange :: ValidationParams -> Ledger.Value -> Integer -> Integer -> Bool
validateSellValueChange !vp !outValue !amount_CampaignToken !amount_ADA=
    let !campaignToken_AC = getCampaignToken_AC vp
        !valueOf_CampaignToken = LedgerValue.assetClassValue campaignToken_AC amount_CampaignToken
        !valueOf_ADA = LedgerADA.lovelaceValueOf amount_ADA
        !valueFor_Control = vInputValue vp <> negate valueOf_CampaignToken <> valueOf_ADA
    in outValue `OnChainHelpers.isEqValue` valueFor_Control

--------------------------------------------------------------------------------
-- GetBack Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateGetBack #-}
validateGetBack :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> T.ValidatorRedeemerGetBackType -> Bool
validateGetBack !vp !outDatum !outValue (T.ValidatorRedeemerGetBackType !amount_CampaignToken) =
    ---------------------
    -- it runs alone
    ---------------------
    -- Que el CampaignFundsDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignFundsDatum se actualiza correctamente con nuevo GetBack
    -- Que el CampaignFundsDatum value cambie con los tokens extraidos
    -- Que el CampaignDatum este en estado CsNotReached | CsFailedMilestone
    ------------------
    -- TODO:
    -- si el caso fuera CsFailedMilestone, hay que devolver proporcionalmente a lo vendido, a cada usuario. No se puede devolver todo.
    -- Usar para eso un total vendido, guardado en CampaignDatum que se actualiza en redeemer ValidatorRedeemerNotReachedCampaign
    ------------------
        traceIfFalse "not isCampaignStatus CsNotReached | CsFailedMilestone"
            (isCampaignStatus vp CampaignT.CsNotReached || isCampaignStatus vp CampaignT.CsFailedMilestone)
        && traceIfFalse "not amount_CampaignToken > 0"
            (amount_CampaignToken > 0)
        && traceIfFalse "not avalaible_ADA >= amount_ADA"
            (T.cfdSubtotal_Avalaible_ADA (vDatum vp) >= amount_ADA)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Updated_With_GetBack"
            (validateGetBackDatumUpdate vp outDatum amount_CampaignToken amount_ADA)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_Changed_With_GetBack"
            (validateGetBackValueChange vp outValue amount_CampaignToken amount_ADA)
        where 
            !amount_ADA = amount_CampaignToken * CampaignT.cdCampaignToken_PriceADA (vCampaignDatum vp)

{-# INLINEABLE validateGetBackDatumUpdate #-}
validateGetBackDatumUpdate :: ValidationParams -> T.CampaignFundsDatumType -> Integer -> Integer -> Bool
validateGetBackDatumUpdate !vp !outDatum !amount_CampaignToken !amount_ADA =
    let !campaignFundsDatum_Out_Control = CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_GetBackTokens
            (vDatum vp)
            amount_CampaignToken
            amount_ADA
    in outDatum `OnChainHelpers.isUnsafeEqDatums` campaignFundsDatum_Out_Control

{-# INLINEABLE validateGetBackValueChange #-}
validateGetBackValueChange :: ValidationParams -> Ledger.Value -> Integer -> Integer -> Bool
validateGetBackValueChange !vp !outValue !amount_CampaignToken !amount_ADA  =
    let !campaignToken_AC = getCampaignToken_AC vp
        !valueOf_CampaignToken = LedgerValue.assetClassValue campaignToken_AC amount_CampaignToken
        !valueOf_ADA = LedgerADA.lovelaceValueOf amount_ADA
        !valueFor_Control = vInputValue vp <> valueOf_CampaignToken <> negate valueOf_ADA
    in outValue `OnChainHelpers.isEqValue` valueFor_Control

--------------------------------------------------------------------------------
-- Collect Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateCollect #-}
validateCollect :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> T.ValidatorRedeemerCollectType -> Bool
validateCollect !vp !outDatum !outValue (T.ValidatorRedeemerCollectType !amount_ADA) =
    ---------------------
    -- 1 - it runs along Campaign Validator, one input, one output (ValidatorRedeemerFundsCollect)
    -- 2 - it runs along Campaign Funds Validator, one input, one output (ValidatorRedeemerCollect)
    ------------------
    -- 1 - Que sea Campaign Admin
    -- 1 - Que el CampaignDatum regrese a Campaign Validator (se hace automaticamente al buscar outputs en same address)
    -- 1 - Que el CampaignDatum este en estado CsReached
    -- 1 - Que el CampaignDatum se actualiza con el pago a los creadores de la campaña
    -- 1 - Que el CampaignDatum value no cambie
    -- 1 - que el redeemer de todos los Campaign Funds Validator sea correcto, mismo redeemer type, misma date, mismo amount.
    -- 1 - Que el monto no supera lo disponible en ese momento: el pago total acumulado hasta ahora menos lo cobrado.
    -- 1 - El pago acumulado hasta ahora es de acuerdo al ultimo milestone aprobado. Siempre que el ultimo milestone estuvira en Creado y no en Fallado.
    -- 1 - Cada milestone establece un porcentaje del total. Tengo el campo de total vendido ADA, y de ahi calculo los porcentajes.
    -- 2 - que el redeemer de Campaign validator sea correcto
    -- 2 - Que todos los CampaignFundsDatum resultantes regrese a Campaign Funds Validator (se hace automaticamente al buscar outputs en same address)
    -- 2 - Que los CampaignFundsDatum datums se actualicen correctamente: solo el campo collected debe modificarse, sumando algun valor.
    -- 2 - Que la suma de todo lo que se saca de cada uno, coincida con amount
    -- 2 - Que los CampaignFundsDatum tengan values actualizados: con menos ADA. Cada uno coincidiendo con el valor de collected del datum
    ------------------
    -- no hay restricciones temporales
    ------------------
    validateCampaignAdminAction vp
        && traceIfFalse "not isCorrectRedeemersCampaignDatum"
            (validateCollectCampaignRedeemer vp)
        && traceIfFalse "not avalaible_ADA_to_Collect_in_Fund >= amount_ADA"
            (T.cfdSubtotal_Avalaible_ADA (vDatum vp) >= amount_ADA)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Updated_With_Collect"
            (validateCollectDatumUpdate vp outDatum amount_ADA)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_Changed_With_Collect"
            (validateCollectValueChange vp outValue amount_ADA)

{-# INLINEABLE validateCollectCampaignRedeemer #-}
validateCollectCampaignRedeemer :: ValidationParams -> Bool
validateCollectCampaignRedeemer !vp =
    let !inputs = [(LedgerApiV2.txInInfoOutRef txIn, LedgerApiV2.txInInfoResolved txIn)
                 | txIn <- LedgerApiV2.txInfoInputs $ vInfo vp]
        !campaignInput = case OnChainHelpers.getTxOutRefs_TxOuts_And_DatumTypes_From_TxOutRefs_TxOuts_By_AC
            @CampaignT.ValidatorDatum
            @CampaignT.CampaignDatumType
            (vCtx vp)
            inputs
            (vCampaignID_AC vp)
            CampaignT.getCampaign_DatumType of
                [x] -> x
                _   -> traceError "Expected one Campaign input"
                
    in  case OnChainHelpers.getRedeemerForConsumeInput ((\(txOutRef, _, _) -> txOutRef) campaignInput) (vInfo vp) of
            Nothing -> traceError "Expected Campaign input with redeemer"
            Just r -> case LedgerApiV2.fromBuiltinData @CampaignT.ValidatorRedeemer $ LedgerApiV2.getRedeemer r of
                Just (CampaignT.ValidatorRedeemerFundsCollect _) -> True
                _                                                -> traceError "Expected Campaign input with valid redeemer ValidatorRedeemerFundsCollect"

{-# INLINEABLE validateCollectDatumUpdate #-}
validateCollectDatumUpdate :: ValidationParams -> T.CampaignFundsDatumType -> Integer -> Bool
validateCollectDatumUpdate !vp !outDatum !amount_ADA =
    let !campaignFundsDatum_Out_Control = CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_Collect
            (vDatum vp)
            amount_ADA
    in outDatum `OnChainHelpers.isUnsafeEqDatums` campaignFundsDatum_Out_Control

{-# INLINEABLE validateCollectValueChange #-}
validateCollectValueChange :: ValidationParams -> Ledger.Value -> Integer -> Bool
validateCollectValueChange !vp !outValue !amount_ADA =
    let !campaignToken_AC = getCampaignToken_AC vp
        !valueOf_CampaignToken = LedgerValue.assetClassValue campaignToken_AC amount_ADA
        !valueFor_Control = vInputValue vp <> negate valueOf_CampaignToken
    in outValue `OnChainHelpers.isEqValue` valueFor_Control

--------------------------------------------------------------------------------
-- Balance Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateBalance #-}
validateBalance :: ValidationParams -> Bool
validateBalance !vp =
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol or Campaign Admin
    -- Que los CampaignFundsDatum regresen a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que los CampaignFundsDatum se actualicen correctamente
    -- Que los CampaignFundsDatum value cambien correctamente
    -- NOTE: se usa zipwith, lo que significa que depende del orden las entradas y salidas. Deben estar en el mismo orden
    -- no hay restricciones temporales
    ------------------
    let !inputDatums = getInputCampaignFundsDatums vp
        !outputDatums = getOutputCampaignFundsDatums vp
    in validateProtocolOrCampaignAdmin vp
        && traceIfFalse "not isCorrect_Outputs_CampaignFunds_Datums_Updated_Balanced" (validateBalancedDatums inputDatums outputDatums)
        && traceIfFalse "not isCorrect_Outputs_CampaignFunds_Datums_Values_Balanced" (validateBalancedValues inputDatums outputDatums vp)

{-# INLINEABLE validateBalancedDatums #-}
validateBalancedDatums :: [(LedgerContextsV2.TxOut, T.CampaignFundsDatumType)] -> [(LedgerContextsV2.TxOut, T.CampaignFundsDatumType)] -> Bool
validateBalancedDatums !inputs !outputs =
    let !inDatums = map snd inputs
        !outDatums = map snd outputs
        !inputSum_Avalaible_CampaignToken = sum $ map T.cfdSubtotal_Avalaible_CampaignToken inDatums
        !outputSum_Avalaible_CampaignToken = sum $ map T.cfdSubtotal_Avalaible_CampaignToken outDatums
        !inputSum_Avalaible_ADA = sum $ map T.cfdSubtotal_Avalaible_ADA inDatums
        !outputSum_Avalaible_ADA = sum $ map T.cfdSubtotal_Avalaible_ADA outDatums
        !validFieldChanges = and $ zipWith sameFieldsExceptAvailable inDatums outDatums
    in inputSum_Avalaible_CampaignToken == outputSum_Avalaible_CampaignToken
        && inputSum_Avalaible_ADA == outputSum_Avalaible_ADA
        && validFieldChanges

{-# INLINEABLE sameFieldsExceptAvailable #-}
sameFieldsExceptAvailable :: T.CampaignFundsDatumType -> T.CampaignFundsDatumType -> Bool
sameFieldsExceptAvailable !input !output =
    T.cfdIndex input == T.cfdIndex output
        && T.cfdCampaignPolicy_CS input == T.cfdCampaignPolicy_CS output
        && T.cfdCampaignFundsPolicyID_CS input == T.cfdCampaignFundsPolicyID_CS output
        && T.cfdSubtotal_Sold_CampaignToken input == T.cfdSubtotal_Sold_CampaignToken output
        && T.cfdSubtotal_Collected_ADA input == T.cfdSubtotal_Collected_ADA output
        && T.cfdMinADA input == T.cfdMinADA output

{-# INLINEABLE validateBalancedValues #-}
validateBalancedValues :: [(LedgerContextsV2.TxOut, T.CampaignFundsDatumType)] -> [(LedgerContextsV2.TxOut, T.CampaignFundsDatumType)] -> ValidationParams -> Bool
validateBalancedValues !inputs !outputs !vp =
    and $ zipWith (validateValueMatch vp) inputs outputs

{-# INLINEABLE validateValueMatch #-}
validateValueMatch :: ValidationParams -> (LedgerContextsV2.TxOut, T.CampaignFundsDatumType) -> (LedgerContextsV2.TxOut, T.CampaignFundsDatumType) -> Bool
validateValueMatch !vp (!inTxOut, !_) (!outTxOut, !outDatum) =
    let !campaignToken_AC = LedgerValue.AssetClass (CampaignT.cdCampaignToken_CS $ vCampaignDatum vp, CampaignT.cdCampaignToken_TN $ vCampaignDatum vp)
        !inCampaignToken_Amount = OnChainHelpers.getAmt_With_AC_InValue (LedgerApiV2.txOutValue inTxOut) campaignToken_AC
        !outCampaignToken_Amount = OnChainHelpers.getAmt_With_AC_InValue (LedgerApiV2.txOutValue outTxOut) campaignToken_AC
        !inADA_Amount = OnChainHelpers.getADAfromValue (LedgerApiV2.txOutValue inTxOut)
        !outADA_Amount = OnChainHelpers.getADAfromValue (LedgerApiV2.txOutValue outTxOut)
        !inCampaignToken_Value = LedgerValue.assetClassValue campaignToken_AC inCampaignToken_Amount
        !outCampaignToken_Value = LedgerValue.assetClassValue campaignToken_AC outCampaignToken_Amount
        !inRest = LedgerApiV2.txOutValue inTxOut
            <> negate inCampaignToken_Value
            <> negate (OnChainHelpers.createADAValue inADA_Amount)
        !outRest = LedgerApiV2.txOutValue outTxOut
            <> negate outCampaignToken_Value
            <> negate (OnChainHelpers.createADAValue outADA_Amount)
    in outCampaignToken_Amount == T.cfdSubtotal_Avalaible_CampaignToken outDatum
        && outADA_Amount == (T.cfdSubtotal_Avalaible_ADA outDatum + T.cfdMinADA outDatum)
        && inRest == outRest

--------------------------------------------------------------------------------
-- Merge Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateMerge #-}
validateMerge :: ValidationParams -> T.CampaignFundsDatumType -> Ledger.Value -> Bool
validateMerge !vp !outDatum !outValue =
    ------------------
    -- 1 - it runs along Campaign Validator, one input, one output (ValidatorRedeemerFundsDelete or ValidatorRedeemerFundsMerge)
    -- 2 - it runs along Campaign Funds ID Policy (PolicyRedeemerBurnID)
    -- 3 - it runs along Campaign Funds Validator, many inputs-one output (ValidatorRedeemerMerge) or many inputs-zero outputs (ValidatorRedeemerDelete)
    ------------------
    -- 1 - Que sea Protocol or Campaig Admin
    -- 1 - Que se quemen CampaignFundsIDs con la correcta póliza CS indicada en CampaignDatum
    -- 1 - Que el CampaignDatum regrese a Campaign Validator (se hace automaticamente al buscar outputs en same address)
    -- 1 - Que el CampaignDatum se actualiza con el Campaign Funds eliminados
    -- 1 - Que el CampaignDatum value no cambie
    -- 2 - Que se quemen CampaignFundsIDs con own póliza
    -- 2 - Que coincida exactamente el total minted con el quantity del redeemer de Campaign Validator (en caso de Merge quantity menos uno)
    -- 2 - Que coincida exactamente el total minted con la cantidad de inputs de Campaign Funds Validator (en caso de Merge hay una input que no se quema)
    -- 2 - que el redeemer de Campaign validator sea correcto
    -- 2 - que el redeemer de todos los Campaign Funds Validator sea correcto
    -- 3 - Que se quemen CampaignFundsIDs con la correcta póliza CS indicada en CampaignFundDatum
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante regrese a Campaign Funds Validator (se hace automaticamente al buscar outputs en same address)
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga el value de todos acumulados
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga en el datum los subtotales acumulados
    -- 3 - En el caso de Delete: que los CampaignFundsDatum no tengan tokens en value
    -- 3 - En el caso de Delete: que los CampaignFundsDatum tengan zero subtotales
    ------------------
    -- no hay restricciones temporales
    ------------------
    let !inputTxOutsAndDatums = getInputCampaignFundsDatums vp
        !inputDatums = map snd inputTxOutsAndDatums
        !inputValues = map (LedgerApiV2.txOutValue . fst) inputTxOutsAndDatums
    in traceIfFalse "not isBurningCampaignFundsIDs"
        ( OnChainHelpers.isToken_Burning_With_CS (vCampaignFundsPolicyID_CS vp) (vInfo vp))
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_SubTotal_Added"
            (validateMergeDatumUpdate outDatum inputDatums)
        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value_Added"
            (validateMergeValueChange vp outValue inputValues)

{-# INLINEABLE validateMergeDatumUpdate #-}
validateMergeDatumUpdate ::T.CampaignFundsDatumType -> [T.CampaignFundsDatumType] -> Bool
validateMergeDatumUpdate !outDatum !inputDatums =
    let !minADA = sum (map T.cfdMinADA inputDatums)
        !avalaible_CampaignToken = sum (map T.cfdSubtotal_Avalaible_CampaignToken inputDatums)
        !sold_CampaignToken = sum (map T.cfdSubtotal_Sold_CampaignToken inputDatums)
        !avalaible_ADA = sum (map T.cfdSubtotal_Avalaible_ADA inputDatums)
        !collected_ADA = sum (map T.cfdSubtotal_Collected_ADA inputDatums)
        !campaignDatum_Out_Control = CampaignHelpers.mkUpdated_CampaignFunds_Datum_With_MergedSubtotals
            outDatum
            avalaible_CampaignToken
            sold_CampaignToken
            avalaible_ADA
            collected_ADA
            minADA
    in outDatum `OnChainHelpers.isUnsafeEqDatums` campaignDatum_Out_Control

{-# INLINEABLE validateMergeValueChange #-}
validateMergeValueChange :: ValidationParams -> Ledger.Value -> [Ledger.Value] -> Bool
validateMergeValueChange !vp !outValue !inputValues =
    let !totalValue = OnChainHelpers.sumValues inputValues
        !valueFor_Burning = OnChainHelpers.getValueOfCurrencySymbol totalValue (vCampaignFundsPolicyID_CS vp)
        !valueFor_Remaining = LedgerValue.assetClassValue (vCampaignFundsID_AC vp) 1
        !valueFor_Control = totalValue <> valueFor_Remaining <> valueFor_Burning
    in outValue `OnChainHelpers.isEqValue` valueFor_Control


--------------------------------------------------------------------------------
-- Delete Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateDelete #-}
validateDelete :: ValidationParams -> Bool
validateDelete !vp =
    ------------------
    -- 1 - it runs along Campaign Validator, one input, one output (ValidatorRedeemerFundsDelete or ValidatorRedeemerFundsMerge)
    -- 2 - it runs along Campaign Funds ID Policy (PolicyRedeemerBurnID)
    -- 3 - it runs along Campaign Funds Validator, many inputs-one output (ValidatorRedeemerMerge) or many inputs-zero outputs (ValidatorRedeemerDelete)
    ------------------
    -- 1 - Que sea Protocol or Campaig Admin
    -- 1 - Que se quemen CampaignFundsIDs con la correcta póliza CS indicada en CampaignDatum
    -- 1 - Que el CampaignDatum regrese a Campaign Validator (se hace automaticamente al buscar outputs en same address)
    -- 1 - Que el CampaignDatum se actualiza con el Campaign Funds eliminados
    -- 1 - Que el CampaignDatum value no cambie
    -- 2 - Que se quemen CampaignFundsIDs con own póliza
    -- 2 - Que coincida exactamente el total minted con el quantity del redeemer de Campaign Validator (en caso de Merge quantity menos uno)
    -- 2 - Que coincida exactamente el total minted con la cantidad de inputs de Campaign Funds Validator (en caso de Merge hay una input que no se quema)
    -- 2 - que el redeemer de Campaign validator sea correcto
    -- 2 - que el redeemer de todos los Campaign Funds Validator sea correcto
    -- 3 - Que se quemen CampaignFundsIDs con la correcta póliza CS indicada en CampaignFundDatum
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante regrese a Campaign Funds Validator (se hace automaticamente al buscar outputs en same address)
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga el value de todos acumulados
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga en el datum los subtotales acumulados
    -- 3 - En el caso de Delete: que los CampaignFundsDatum no tengan tokens en value
    -- 3 - En el caso de Delete: que los CampaignFundsDatum tengan zero subtotales
    ------------------
    -- no hay restricciones temporales
    ------------------
    --TODO: agregar control, si la campaña está en estado alguno que sea activo, solo se borra si tiene zero subtotals y minADA only
    -- pero si esta todo terminado y es para limpiar, deberia permitir, con min ada only, pero sin imporatrn si collected o sold son distintos de zero
    ------------------
    traceIfFalse "not isBurningCampaignFundsIDs" ( OnChainHelpers.isToken_Burning_With_CS (vCampaignFundsPolicyID_CS vp) (vInfo vp))
        && traceIfFalse "not isZeroSubtotals" (isZeroSubtotals $ vDatum vp)
        && traceIfFalse "not isMinADAAndIDOnlyValue" (vInputValue vp `OnChainHelpers.isEqValue` (LedgerAda.lovelaceValueOf (T.cfdMinADA $ vDatum vp) <> LedgerValue.assetClassValue (vCampaignFundsID_AC vp) 1))
    where 
        isZeroSubtotals :: T.CampaignFundsDatumType -> Bool
        isZeroSubtotals !datum =
            T.cfdSubtotal_Avalaible_CampaignToken datum == 0
                && T.cfdSubtotal_Sold_CampaignToken datum == 0
                && T.cfdSubtotal_Avalaible_ADA datum == 0
                && T.cfdSubtotal_Collected_ADA datum == 0

--------------------------------------------------------------------------------
-- Helper Functions
--------------------------------------------------------------------------------

{-# INLINEABLE getOwnInputs #-}
getOwnInputs :: LedgerApiV2.TxInfo -> LedgerApiV2.Address -> [LedgerContextsV2.TxOut]
getOwnInputs !info !add =
    [ LedgerApiV2.txInInfoResolved txInfoInput
    | txInfoInput <- LedgerApiV2.txInfoInputs info
    , let address = LedgerApiV2.txOutAddress (LedgerApiV2.txInInfoResolved txInfoInput)
    , OnChainHelpers.isScriptAddress address && address == add
    ]

{-# INLINEABLE getOwnOutputs #-}
getOwnOutputs :: LedgerApiV2.TxInfo -> LedgerApiV2.Address ->[LedgerContextsV2.TxOut]
getOwnOutputs !info !add =
    [ output
    | output <- LedgerApiV2.txInfoOutputs info
     , let address = LedgerApiV2.txOutAddress output
    , OnChainHelpers.isScriptAddress address && address == add
    ]

{-# INLINEABLE getRefInputs #-}
getRefInputs :: ValidationParams -> [LedgerContextsV2.TxOut]
getRefInputs !vp =
    [ LedgerApiV2.txInInfoResolved txInfoInput
    | txInfoInput <- LedgerApiV2.txInfoReferenceInputs $ vInfo vp
    , OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress $ LedgerApiV2.txInInfoResolved txInfoInput)
    ]

{-# INLINEABLE getProtocol_Datum #-}
getProtocol_Datum :: ValidationParams -> Maybe ProtocolT.ProtocolDatumType
getProtocol_Datum !vp =
    let !refInputs = getRefInputs vp
        !protocolDatums = OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_AC
            (vCtx vp)
            refInputs
            (vProtocolID_AC vp)
            ProtocolT.getProtocol_DatumType
    in case protocolDatums of
        [(_,x)] -> Just x
        _   -> Nothing

{-# INLINEABLE getCampaign_Datum #-}
getCampaign_Datum :: LedgerContextsV2.ScriptContext -> LedgerValue.AssetClass -> Bool -> CampaignT.CampaignDatumType
getCampaign_Datum !ctx !campaignID_AC !useNormalInput =
    let inputs = if useNormalInput
            then [(LedgerApiV2.txInInfoOutRef txIn, LedgerApiV2.txInInfoResolved txIn)
                | txIn <- LedgerApiV2.txInfoInputs $ LedgerContextsV2.scriptContextTxInfo ctx]
            else [(LedgerApiV2.txInInfoOutRef txIn, LedgerApiV2.txInInfoResolved txIn)
                | txIn <- LedgerApiV2.txInfoReferenceInputs $ LedgerContextsV2.scriptContextTxInfo ctx]
        campaignDatums = OnChainHelpers.getTxOutRefs_TxOuts_And_DatumTypes_From_TxOutRefs_TxOuts_By_AC
            @CampaignT.ValidatorDatum
            @CampaignT.CampaignDatumType
            ctx
            inputs
            campaignID_AC
            CampaignT.getCampaign_DatumType
    in case campaignDatums of
        [(_, _, datum)] -> datum
        _ -> traceError $ if useNormalInput
             then "Expected exactly one Campaign normal input"
             else "Expected exactly one Campaign reference input"

{-# INLINEABLE getOutput_CampaignFunds_DatumAndValue #-}
getOutput_CampaignFunds_DatumAndValue :: ValidationParams -> Maybe (T.CampaignFundsDatumType, Ledger.Value)
getOutput_CampaignFunds_DatumAndValue !vp =
    case vOwnOutputs vp of
        [output] ->
            let !maybeTxOut = OnChainHelpers.getTxOut_And_DatumType_From_TxOut_And_AC_And_Address
                    @T.ValidatorDatum
                    @T.CampaignFundsDatumType
                    (vCtx vp)
                    output
                    (vCampaignFundsID_AC vp)
                    (Just $ vOwnAddress vp)
                    T.getCampaignFunds_DatumType
            in case maybeTxOut of
                Just txOut -> Just (OnChainHelpers.getDatum_In_TxOut_And_Datum txOut, LedgerApiV2.txOutValue output)
                Nothing    -> Nothing
        _ -> Nothing

{-# INLINEABLE getInputCampaignFundsDatums #-}
getInputCampaignFundsDatums :: ValidationParams -> [(LedgerContextsV2.TxOut, T.CampaignFundsDatumType)]
getInputCampaignFundsDatums !vp =
    OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_CS
        @T.ValidatorDatum
        @T.CampaignFundsDatumType
        (vCtx vp)
        (vOwnInputs vp)
        (vCampaignFundsPolicyID_CS vp)
        T.getCampaignFunds_DatumType

{-# INLINEABLE getOutputCampaignFundsDatums #-}
getOutputCampaignFundsDatums :: ValidationParams -> [(LedgerContextsV2.TxOut, T.CampaignFundsDatumType)]
getOutputCampaignFundsDatums !vp =
    OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_CS
        @T.ValidatorDatum
        @T.CampaignFundsDatumType
        (vCtx vp)
        (vOwnOutputs vp)
        (vCampaignFundsPolicyID_CS vp)
        T.getCampaignFunds_DatumType


{-# INLINEABLE getCampaignToken_AC #-}
getCampaignToken_AC :: ValidationParams -> LedgerValue.AssetClass
getCampaignToken_AC !vp =
    LedgerValue.AssetClass
        (CampaignT.cdCampaignToken_CS $ vCampaignDatum vp,
         CampaignT.cdCampaignToken_TN $ vCampaignDatum vp)

{-# INLINEABLE isCampaignOpen #-}
isCampaignOpen :: ValidationParams -> Bool
isCampaignOpen !vp =
    let !datum = vCampaignDatum vp
        !info = vInfo vp
    in OnChainHelpers.isDateReached (CampaignT.cdBeginAt datum) info
       && not (OnChainHelpers.isDateReached (CampaignT.cdDeadline datum) info)

{-# INLINEABLE isCampaignFinish #-}
isCampaignFinish :: ValidationParams -> Bool
isCampaignFinish = not . isCampaignOpen

{-# INLINEABLE isCampaignStatus #-}
isCampaignStatus :: ValidationParams -> CampaignT.CapaignStatus -> Bool
isCampaignStatus !vp !status = CampaignT.cdStatus (vCampaignDatum vp) == status



--------------------------------------------------------------------------------

{-# INLINEABLE checkUnique #-}
checkUnique :: ValidationParams -> Bool
checkUnique !vp = T.vpProtocolPolicyID_CS (vParams vp) /= LedgerApiV2.adaSymbol

--------------------------------------------------------------------------------
-- Authorization Functions
--------------------------------------------------------------------------------

{-# INLINEABLE isAdminTokenPresent #-}
isAdminTokenPresent :: ValidationParams -> Bool
isAdminTokenPresent !vp =
    case LedgerApiV2.txInfoOutputs $ vInfo vp of
        []           -> False
        (output : _) ->
            let !tokenAdmin_AC = LedgerValue.AssetClass (T.getAdminToken_CS $ vCampaignDatum vp, T.tokenAdmin_TN)
            in OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue output) tokenAdmin_AC

{-# INLINEABLE validateCampaignAdminAction #-}
validateCampaignAdminAction :: ValidationParams -> Bool
validateCampaignAdminAction !vp =
    ------------------
    -- Que este el token de admin presente
    -- o Que sea Campaign Admin
    ------------------
    traceIfFalse "not isSignedByAny admins nor isAdminTokenPresent"
        (OnChainHelpers.isSignedByAny (T.getAdmins $ vCampaignDatum vp) (vInfo vp) || isAdminTokenPresent vp)

{-# INLINEABLE validateProtocolOrCampaignAdmin #-}
validateProtocolOrCampaignAdmin :: ValidationParams -> Bool
validateProtocolOrCampaignAdmin !vp =
    ------------------
    -- Que este el token de admin presente
    -- o Que sea Campaign Admin
    -- o Que sea Protocol Admin si hay input ref protocol
    ------------------
    let !protocolDatum = getProtocol_Datum vp
        !admins = T.getAdmins (vCampaignDatum vp) ++ maybe [] T.getAdmins protocolDatum
    in traceIfFalse "not isSignedByAny admins nor isAdminTokenPresent"
        (OnChainHelpers.isSignedByAny admins (vInfo vp) || isAdminTokenPresent vp)

----------------------------------------------------------------------------

{-# INLINEABLE mkPolicyID #-}
mkPolicyID :: T.PolicyParams -> BuiltinData -> BuiltinData -> ()
mkPolicyID (T.PolicyParams !campaignPolicy_CS !campaignFundsValidator_Hash) !redRaw !ctxRaw =
    if traceIfFalse "" useThisToMakeScriptUnique
        && traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange info T.validTxTimeRange)
        && validateMintAndBurnIDRedeemers
        then ()
        else error ()
    where
        ------------------
        !useThisToMakeScriptUnique = campaignPolicy_CS /= LedgerApiV2.adaSymbol
        ------------------
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.PolicyRedeemer redRaw
        !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
        !campaignFundsPolicyID_CS = LedgerContextsV2.ownCurrencySymbol ctx
        ------------------
        !ownMintingValue = OnChainHelpers.getUnsafeOwnMintingValue ctx
        ------------------
        validateMintAndBurnIDRedeemers :: Bool
        validateMintAndBurnIDRedeemers =
            case redeemer of
                (T.PolicyRedeemerMintID _) ->
                    ------------------
                    -- it runs along with Campaign Validator (ValidatorRedeemerFundsAdd)
                    -- validateAdminAction
                    -- traceIfFalse "not isCorrect_Output_Campaign_Datum_With_CampaignFundsAdded" isCorrect_Output_Campaign_Datum_With_CampaignFundsAdded
                    -- && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged" isCorrect_Output_Campaign_Datum_Value_NotChanged
                    -- && traceIfFalse "not isMintingCampaignFundsID" isMintingCampaignFundsID
                    -- && traceIfFalse "not isCampaignOpen" isCampaignOpen
                    ------------------
                    -- Que se consuma CampaignDatum con redeemer correcto (ValidatorRedeemerFundsAdd)
                    -- Para identificar el correcto CampaignDatum necesita la póliza Campaign ID que está en los parámetros de esta póliza.
                    -- Que se genere salida con nuevo CampaignFunds Datum en CampaignFunds Validator (CampaignFunds Validator está indicada en CampaignDatum)
                    -- Que el CampaignFunds Datum sea correcto
                    -- Que se mintee CampaignFunds ID con own póliza
                    -- Que el CampaignFunds Datum tenga el CampaignFunds ID
                    ------------------
                    traceIfFalse "not isMintingCampaignFundsID" isMintingCampaignFundsID
                        && traceIfFalse "not isCorrect_Redeemer_CampaignDatum" (isCorrect_Redeemer_CampaignDatum isCampaignValidatorRedeemerFundsAdd)
                        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum" isCorrect_Output_CampaignFunds_Datum
                        && traceIfFalse "not isCorrect_Output_CampaignFunds_Datum_Value" isCorrect_Output_CampaignFunds_Datum_Value
                    where
                        ------------------

                        ------------------
                        !outputs_txOuts =
                            [ txOut | txOut <- LedgerApiV2.txInfoOutputs info, OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress txOut)
                            ]
                        ------------------
                        !_ =
                            if length outputs_txOuts < 2
                                then traceError "Expected at least two outputs to scripts addresses"
                                else ()
                        ------------------
                        -- 0 out is the CampaignDatum
                        -- 1 out is the CampaignFundsDatum
                        ------------------
                        !input_TxOut_And_CampaignDatum = (\(_, txOut, datum) -> (txOut, datum)) input_TxOutRef_TxOut_And_CampaignDatum
                        ------------------
                        !campaignDatum_In = OnChainHelpers.getDatum_In_TxOut_And_Datum input_TxOut_And_CampaignDatum
                        ------------------
                        !campaignFunds_Index = CampaignT.cdFundsIndex campaignDatum_In
                        !campaignFundsID_TN = LedgerApiV2.TokenName $ T.campaignFundsID_TN_basename <> OnChainHelpers.intToBBS campaignFunds_Index
                        !campaignFundsID_AC = LedgerValue.AssetClass (campaignFundsPolicyID_CS, campaignFundsID_TN)
                        ------------------
                        !campaignFundsValidator_Address = Ledger.scriptHashAddress campaignFundsValidator_Hash
                        ------------------
                        !output_Own_TxOut_And_CampaignFundsDatum =
                            fromMaybe
                                (traceError "Expected CampaignFunds at output index 1")
                                ( OnChainHelpers.getTxOut_And_DatumType_From_TxOut_And_AC_And_Address
                                    @T.ValidatorDatum
                                    @T.CampaignFundsDatumType
                                    ctx
                                    (outputs_txOuts !! 1)
                                    campaignFundsID_AC
                                    (Just campaignFundsValidator_Address)
                                    T.getCampaignFunds_DatumType
                                )
                        ------------------
                        !campaignFundsDatum_Out = OnChainHelpers.getDatum_In_TxOut_And_Datum output_Own_TxOut_And_CampaignFundsDatum
                        ------------------
                        !valueFor_Mint_CampaignFundsID = LedgerValue.assetClassValue campaignFundsID_AC 1
                        ------------------
                        !minADA_For_CampaignFundsDatum_Out = T.cfdMinADA campaignFundsDatum_Out
                        !value_MinADA_For_CampaignFundsDatum_Out = LedgerAda.lovelaceValueOf minADA_For_CampaignFundsDatum_Out
                        !valueFor_CampaignFundsDatum_Out_Control = valueFor_Mint_CampaignFundsID <> value_MinADA_For_CampaignFundsDatum_Out
                        ------------------
                        !campaignFundsDatum_Out_Control =
                            T.CampaignFundsDatumType
                                { T.cfdIndex = campaignFunds_Index
                                , T.cfdCampaignPolicy_CS = campaignPolicy_CS
                                , T.cfdCampaignFundsPolicyID_CS = campaignFundsPolicyID_CS
                                , T.cfdSubtotal_Avalaible_CampaignToken = 0
                                , T.cfdSubtotal_Sold_CampaignToken = 0
                                , T.cfdSubtotal_Avalaible_ADA = 0
                                , T.cfdSubtotal_Collected_ADA = 0
                                , T.cfdMinADA = minADA_For_CampaignFundsDatum_Out
                                }
                        ------------------
                        isCampaignValidatorRedeemerFundsAdd :: CampaignT.ValidatorRedeemer -> Bool
                        isCampaignValidatorRedeemerFundsAdd redemeerToCheck = case redemeerToCheck of
                            CampaignT.ValidatorRedeemerFundsAdd _ -> True
                            _                                     -> False
                        ------------------
                        isMintingCampaignFundsID :: Bool
                        isMintingCampaignFundsID = ownMintingValue `OnChainHelpers.isEqValue` valueFor_Mint_CampaignFundsID
                        -----------------
                        isCorrect_Output_CampaignFunds_Datum :: Bool
                        isCorrect_Output_CampaignFunds_Datum =
                            campaignFundsDatum_Out `OnChainHelpers.isUnsafeEqDatums` campaignFundsDatum_Out_Control
                        ------------------
                        isCorrect_Output_CampaignFunds_Datum_Value :: Bool
                        isCorrect_Output_CampaignFunds_Datum_Value =
                            let
                                !valueOf_CampaignFundsDatum_Out = OnChainHelpers.getValue_In_TxOut_And_Datum output_Own_TxOut_And_CampaignFundsDatum
                            in
                                valueOf_CampaignFundsDatum_Out `OnChainHelpers.isEqValue` valueFor_CampaignFundsDatum_Out_Control
                ------------------
                (T.PolicyRedeemerBurnID _) ->
                    ------------------
                    -- 1 - it runs along Campaign Validator, one input, one output (ValidatorRedeemerFundsDelete or ValidatorRedeemerFundsMerge)
                    -- 2 - it runs along CampaignFunds ID Policy (PolicyRedeemerBurnID)
                    -- 3 - it runs along CampaignFunds Validator ,  many inputs-one output (ValidatorRedeemerMerge) or many inputs-zero outputs (ValidatorRedeemerDelete)
                    ------------------
                    -- 1 - Que sea Protocol or Campaig Admin
                    -- 1 y 3 - Que se quemen CampaignFundsIDs con la correcta póliza indicada en CampaignDatum o CampaignFunds Datum
                    -- 2 - Que se quemen CampaignFundsIDs con own póliza
                    -- 2 - Qque coincida exactamente el total minted con el quantity del redeemer de Campaign Validator (en caso de Merge quantity menos uno)
                    -- 2 - Que coincida exactamente el total minted con la cantidad de inputs de CampaignFunds Validator (en caso de Merge hay una input que no se quema)
                    -- 2 - que el redeemer de Campaign validator sea correcto
                    -- 2 - que el redeemer de todos los CampaignFunds Validator sea correcto
                    -- 1 - Que el CampaignDatum regrese a Campaign Validator (se hace automaticamente al buscar outputs en same address)
                    -- 1 - Que el CampaignDatum se actualiza con el CampaignFunds eliminados
                    -- 1 - Que el CampaignDatum value no cambie
                    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante regrese a CampaignFunds Validator (se hace automaticamente al buscar outputs en same address)
                    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga el value de todos acumulados
                    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga en el datum los subtotales acumulados
                    -- 3 - En el caso de Delete: que los CampaignFundsDatum no tengan tokens en value
                    -- 3 - En el caso de Delete: que los CampaignFundsDatum tengan zero subtotales
                    -- no hay restricciones temporales
                    ------------------
                    traceIfFalse "not isBurningCampaignFundsIDs" isBurningCampaignFundsIDs
                        && traceIfFalse "not isCorrect_Redeemer_CampaignDatum" (isCorrect_Redeemer_CampaignDatum isCampaignValidatorRedeemerFundsMergeOrDelete )
                        -- && traceIfFalse "not isZeroAssets" isZeroAssets
                    where
                        ------------------
                        -- !input_TxOutRef_TxOut_And_CampaignFundsDatum =
                        --     case OnChainHelpers.getTxOutRefs_TxOuts_And_DatumTypes_From_TxOutRefs_TxOuts_By_CS
                        --         @T.ValidatorDatum
                        --         @T.CampaignFundsDatumType
                        --         ctx
                        --         inputs_TxOutRefs_TxOuts
                        --         campaignFundsPolicyID_CS
                        --         T.getCampaignFunds_DatumType of
                        --         [x] -> x
                        --         _   -> traceError "Expected exactly one CampaignFunds input"
                        -- ------------------
                        -- !input_TxOut_And_CampaignFundsDatum = (\(_, txOut, datum) -> (txOut, datum)) input_TxOutRef_TxOut_And_CampaignFundsDatum
                        -- ------------------
                        -- -- !campaignFundsDatum_In = OnChainHelpers.getDatum_In_TxOut_And_Datum input_TxOut_And_CampaignFundsDatum
                        -- -- ------------------
                        -- -- !campaignFunds_Index = T.cfdIndex campaignFundsDatum_In
                        -- -- !campaignFundsID_TN = LedgerApiV2.TokenName $ T.campaignFundsID_TN_basename <> OnChainHelpers.intToBBS campaignFunds_Index
                        -- -- !campaignFundsID_AC = LedgerValue.AssetClass (campaignFundsPolicyID_CS, campaignFundsID_TN)
                        -- -- ------------------
                        -- -- !valueFor_Mint_CampaignFundsID = LedgerValue.assetClassValue campaignFundsID_AC 1
                        -- !valueFor_Burn_CampaignFundsID = LedgerValue.assetClassValue campaignFundsID_AC (negate 1)
                        ------------------
                        isBurningCampaignFundsIDs :: Bool
                        isBurningCampaignFundsIDs = OnChainHelpers.isToken_Burning_With_CS campaignFundsPolicyID_CS info && ownMintingValue `OnChainHelpers.isEqValue` OnChainHelpers.getValueOfCurrencySymbol ownMintingValue campaignFundsPolicyID_CS
                        -----------------
                        isCampaignValidatorRedeemerFundsMergeOrDelete :: CampaignT.ValidatorRedeemer -> Bool
                        isCampaignValidatorRedeemerFundsMergeOrDelete redemeerToCheck = case redemeerToCheck of
                            CampaignT.ValidatorRedeemerFundsDelete _ -> True
                            CampaignT.ValidatorRedeemerFundsMerge _ -> True
                            _                                        -> False
                        ------------------
                        -- isZeroAssets :: Bool
                        -- !isZeroAssets =
                        --     let
                        --         ------------------
                        --         !minADA_For_CampaignFundsDatum_In = T.cfdMinADA campaignFundsDatum_In
                        --         !value_MinADA_For_CampaignFundsDatum_In = LedgerAda.lovelaceValueOf minADA_For_CampaignFundsDatum_In
                        --         !valueFor_CampaignFundsDatum_In_Control = valueFor_Mint_CampaignFundsID <> value_MinADA_For_CampaignFundsDatum_In
                        --         ------------------
                        --         !valueOf_CampaignFundsDatum_In = OnChainHelpers.getValue_In_TxOut_And_Datum input_TxOut_And_CampaignFundsDatum
                        --     in
                        --         valueOf_CampaignFundsDatum_In `OnChainHelpers.isEqValue` valueFor_CampaignFundsDatum_In_Control
            where
                ------------------
                !campaignID_AC = LedgerValue.AssetClass (campaignPolicy_CS, T.campaignID_TN)
                ------------------
                !inputs_TxOutRefs_TxOuts =
                    [ (LedgerApiV2.txInInfoOutRef txInfoInput, LedgerApiV2.txInInfoResolved txInfoInput) | txInfoInput <- LedgerApiV2.txInfoInputs info, OnChainHelpers.isScriptAddress $ LedgerApiV2.txOutAddress (LedgerApiV2.txInInfoResolved txInfoInput)
                    ]
                ------------------
                !input_TxOutRef_TxOut_And_CampaignDatum =
                    case OnChainHelpers.getTxOutRefs_TxOuts_And_DatumTypes_From_TxOutRefs_TxOuts_By_AC
                        @CampaignT.ValidatorDatum
                        @CampaignT.CampaignDatumType
                        ctx
                        inputs_TxOutRefs_TxOuts
                        campaignID_AC
                        CampaignT.getCampaign_DatumType of
                        [x] -> x
                        _   -> traceError "Expected exactly one Campaign input"
                ------------------
                get_Redeemer_CampaignDatum :: Maybe CampaignT.ValidatorRedeemer
                get_Redeemer_CampaignDatum  =
                    let
                        !redeemerFor_CampaignDatum' = OnChainHelpers.getRedeemerForConsumeInput ((\(txOutRef, _, _) -> txOutRef) input_TxOutRef_TxOut_And_CampaignDatum) info
                    in
                        case redeemerFor_CampaignDatum' of
                            Nothing                        -> Nothing
                            Just redeemerFor_CampaignDatum -> LedgerApiV2.fromBuiltinData @CampaignT.ValidatorRedeemer $ LedgerApiV2.getRedeemer redeemerFor_CampaignDatum
                ------------------
                isCorrect_Redeemer_CampaignDatum :: (CampaignT.ValidatorRedeemer -> Bool) -> Bool
                isCorrect_Redeemer_CampaignDatum isRedeemerType =
                    case get_Redeemer_CampaignDatum of
                                Just x -> isRedeemerType x
                                _      -> False

----------------------------------------------------------------------------2

{-# INLINEABLE policyID #-}
policyID :: T.PolicyParams -> LedgerApiV2.MintingPolicy
policyID params =
    Plutonomy.optimizeUPLC $
        Plutonomy.mintingPolicyToPlutus $
            Plutonomy.mkMintingPolicyScript $
                $$(PlutusTx.compile [||mkPolicyID||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINEABLE mkWrappedPolicyID #-}
mkWrappedPolicyID :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedPolicyID campaignPolicy_CS campaignFundsValidator_Hash = mkPolicyID params
    where
        params =
            T.PolicyParams
                { ppCampaignPolicy_CS = PlutusTx.unsafeFromBuiltinData campaignPolicy_CS
                , ppCampaignFundsValidator_Hash = PlutusTx.unsafeFromBuiltinData campaignFundsValidator_Hash
                }

policyIDCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())
policyIDCode = Plutonomy.optimizeUPLC $$(PlutusTx.compile [||mkWrappedPolicyID||])

----------------------------------------------------------------------------2

{-# INLINEABLE validator #-}
validator :: T.ValidatorParams -> LedgerApiV2.Validator
validator params =
    Plutonomy.optimizeUPLC $
        Plutonomy.validatorToPlutus $
            Plutonomy.mkValidatorScript $
                $$(PlutusTx.compile [||mkValidator||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINEABLE mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator protocolPolicyID_CS tokenEmergencyAdminPolicy_CS = mkValidator params
    where
        params =
            T.ValidatorParams
                { vpProtocolPolicyID_CS = PlutusTx.unsafeFromBuiltinData protocolPolicyID_CS
                , vpTokenEmergencyAdminPolicy_CS = PlutusTx.unsafeFromBuiltinData tokenEmergencyAdminPolicy_CS
                }

validatorCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())
validatorCode = Plutonomy.optimizeUPLC $$(PlutusTx.compile [||mkWrappedValidator||])

----------------------------------------------------------------------------2

====== Campaign/Funds/Types.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE InstanceSigs          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Campaign.Funds.Types where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Data.Aeson           as DataAeson (FromJSON, ToJSON)
import qualified Data.OpenApi.Schema  as DataOpenApiSchema (ToSchema)
import qualified GHC.Generics         as GHCGenerics (Generic)
import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import qualified PlutusTx
import           PlutusTx.Prelude
import qualified Prelude              as P
import qualified Schema

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Campaign.Types       as FundT
import qualified Constants            as T
import qualified Helpers.OnChain      as OnChainHelpers
import qualified Helpers.Types        as T
import qualified Protocol.Types       as ProtocolT
import qualified Types                as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

-- Any change in the logic, datum or redeemer must change the version of the campaignVersion on Campaign.Types

ownVersion :: Integer
ownVersion = T.mkVersionWithDependency [ProtocolT.protocolVersion] FundT.campaignVersion

--------------------------------------------------------------------------------2
-- Params
--------------------------------------------------------------------------------2

data PolicyParams
    = PolicyParams
          { ppCampaignPolicy_CS           :: LedgerApiV2.CurrencySymbol
          , ppCampaignFundsValidator_Hash :: LedgerApiV2.ValidatorHash
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

instance Eq PolicyParams where
    {-# INLINEABLE (==) #-}
    pp1 == pp2 =
        ppCampaignPolicy_CS pp1 == ppCampaignPolicy_CS pp2 &&
        ppCampaignFundsValidator_Hash pp1 == ppCampaignFundsValidator_Hash pp2


PlutusTx.makeLift ''PolicyParams
PlutusTx.makeIsDataIndexed
    ''PolicyParams
    [ ('PolicyParams, 0)
    ]

data ValidatorParams
    = ValidatorParams
          { vpProtocolPolicyID_CS          :: LedgerApiV2.CurrencySymbol
          , vpTokenEmergencyAdminPolicy_CS :: LedgerApiV2.CurrencySymbol
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

-- instance Schema.ToSchema ValidatorParams where
--     toSchema = Schema.FormSchemaUnit

instance Eq ValidatorParams where
    {-# INLINEABLE (==) #-}
    pp1 == pp2 =
        vpProtocolPolicyID_CS pp1 == vpProtocolPolicyID_CS pp2 &&
        vpTokenEmergencyAdminPolicy_CS pp1 == vpTokenEmergencyAdminPolicy_CS pp2

PlutusTx.makeLift ''ValidatorParams
PlutusTx.makeIsDataIndexed
    ''ValidatorParams
    [ ('ValidatorParams, 0)
    ]

--------------------------------------------------------------------------------2
-- Datums
--------------------------------------------------------------------------------2

data CampaignFundsDatumType
    = CampaignFundsDatumType
          { cfdVersion                          :: Integer
          , cfdIndex                            :: Integer
          , cfdCampaignPolicy_CS                :: T.CS
          , cfdCampaignFundsPolicyID_CS         :: T.CS
          , cfdSubtotal_Avalaible_CampaignToken :: Integer
          , cfdSubtotal_Sold_CampaignToken      :: Integer
          , cfdSubtotal_Avalaible_ADA           :: Integer
          , cfdSubtotal_Collected_ADA           :: Integer
          , cfdMinADA                           :: Integer
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq CampaignFundsDatumType where
    {-# INLINEABLE (==) #-}
    ps1 == ps2 =
        cfdVersion ps1 == cfdVersion ps2
            && cfdIndex ps1 == cfdIndex ps2
            && cfdCampaignPolicy_CS ps1 == cfdCampaignPolicy_CS ps2
            && cfdCampaignFundsPolicyID_CS ps1 == cfdCampaignFundsPolicyID_CS ps2
            && cfdSubtotal_Avalaible_CampaignToken ps1 == cfdSubtotal_Avalaible_CampaignToken ps2
            && cfdSubtotal_Sold_CampaignToken  ps1 == cfdSubtotal_Sold_CampaignToken  ps2
            && cfdSubtotal_Avalaible_ADA  ps1 == cfdSubtotal_Avalaible_ADA  ps2
            && cfdSubtotal_Collected_ADA  ps1 == cfdSubtotal_Collected_ADA  ps2
            && cfdMinADA ps1 == cfdMinADA ps2

instance Ord CampaignFundsDatumType where
    {-# INLINEABLE compare #-}
    compare :: CampaignFundsDatumType -> CampaignFundsDatumType -> Ordering
    compare a b = compare (cfdIndex a) (cfdIndex b)

PlutusTx.makeIsDataIndexed
    ''CampaignFundsDatumType
    [ ('CampaignFundsDatumType, 0)
    ]

--------------------------------------------------------------------------------2

newtype ValidatorDatum
    = CampaignFundsDatum CampaignFundsDatumType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq ValidatorDatum where
    {-# INLINEABLE (==) #-}
    CampaignFundsDatum mps1 == CampaignFundsDatum mps2 = mps1 == mps2

PlutusTx.makeIsDataIndexed
    ''ValidatorDatum
    [ ('CampaignFundsDatum, 0)
    ]

{-# INLINEABLE getCampaignFunds_DatumType #-}
getCampaignFunds_DatumType :: ValidatorDatum -> CampaignFundsDatumType
getCampaignFunds_DatumType (CampaignFundsDatum sdType) = sdType

{-# INLINEABLE getCampaignFunds_DatumType_From_UTxO #-}
getCampaignFunds_DatumType_From_UTxO :: LedgerApiV2.TxOut -> CampaignFundsDatumType
getCampaignFunds_DatumType_From_UTxO utxo = case OnChainHelpers.getInlineDatum_From_TxOut @ValidatorDatum utxo of
                    Nothing     -> P.error "No CampaignFunds Datum found"
                    Just datum' -> getCampaignFunds_DatumType datum'

instance T.ShowDatum ValidatorDatum where
    showCborAsDatumType cbor = case LedgerApiV2.fromBuiltinData @ValidatorDatum cbor of
        Nothing -> Nothing
        Just d  -> Just $ P.show d

--------------------------------------------------------------------------------2

{-# INLINEABLE mkCampaignFunds_DatumType #-}
mkCampaignFunds_DatumType :: Integer -> T.CS -> T.CS -> Integer -> Integer -> Integer -> Integer -> Integer -> CampaignFundsDatumType
mkCampaignFunds_DatumType = CampaignFundsDatumType ownVersion

{-# INLINEABLE mkCampaignFunds_Datum #-}
mkCampaignFunds_Datum :: Integer ->  T.CS -> T.CS -> Integer -> Integer -> Integer -> Integer -> Integer ->  ValidatorDatum
mkCampaignFunds_Datum
    index
    campaignPolicy_CS
    campaignFundsPolicyID_CS
    subtotal_Avalaible_CampaignToken
    subtotal_Sold_CampaignToken
    subtotal_Avalaible_ADA
    subtotal_Collected_ADA
    minADA
     =
        CampaignFundsDatum $
            mkCampaignFunds_DatumType
                index
                campaignPolicy_CS
                campaignFundsPolicyID_CS
                subtotal_Avalaible_CampaignToken
                subtotal_Sold_CampaignToken
                subtotal_Avalaible_ADA
                subtotal_Collected_ADA
                minADA

mkDatum :: CampaignFundsDatumType -> LedgerApiV2.Datum
mkDatum = LedgerApiV2.Datum . LedgerApiV2.toBuiltinData . CampaignFundsDatum

--------------------------------------------------------------------------------2
-- PolicyRedeemer
--------------------------------------------------------------------------------2

data PolicyRedeemerMintIDType = PolicyRedeemerMintIDType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerMintIDType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed ''PolicyRedeemerMintIDType [('PolicyRedeemerMintIDType, 0)]

data PolicyRedeemerBurnIDType = PolicyRedeemerBurnIDType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerBurnIDType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemerBurnIDType
    [ ('PolicyRedeemerBurnIDType, 0)
    ]

data PolicyRedeemer
    = PolicyRedeemerMintID PolicyRedeemerMintIDType
    | PolicyRedeemerBurnID PolicyRedeemerBurnIDType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemer where
    {-# INLINEABLE (==) #-}
    PolicyRedeemerMintID rmtx1 == PolicyRedeemerMintID rmtx2 = rmtx1 == rmtx2
    PolicyRedeemerBurnID rmtx1 == PolicyRedeemerBurnID rmtx2 = rmtx1 == rmtx2
    _ == _                                                   = False

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemer
    [ ('PolicyRedeemerMintID, 0)
    , ('PolicyRedeemerBurnID, 1)
    ]

--------------------------------------------------------------------------------2

getPolicyRedeemerName :: Maybe PolicyRedeemer -> Maybe P.String
getPolicyRedeemerName (Just (PolicyRedeemerMintID PolicyRedeemerMintIDType)) = Just "MintID"
getPolicyRedeemerName (Just (PolicyRedeemerBurnID PolicyRedeemerBurnIDType)) = Just "BurnID"
getPolicyRedeemerName _                                                      = Nothing

--------------------------------------------------------------------------------22
-- ValidatorRedeemer
--------------------------------------------------------------------------------2

data ValidatorRedeemerUpdateMinADAType = ValidatorRedeemerUpdateMinADAType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerUpdateMinADAType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed ''ValidatorRedeemerUpdateMinADAType [('ValidatorRedeemerUpdateMinADAType, 0)]

--------------------------------------------------------------------------------2

newtype ValidatorRedeemerDepositType
    = ValidatorRedeemerDepositType { rdAmount :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerDepositType where
    {-# INLINEABLE (==) #-}
    r1 == r2 =
        rdAmount r1 == rdAmount r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerDepositType
    [ ('ValidatorRedeemerDepositType, 0)
    ]

--------------------------------------------------------------------------------2

newtype ValidatorRedeemerWithdrawType
    = ValidatorRedeemerWithdrawType { rwAmount :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerWithdrawType where
    {-# INLINEABLE (==) #-}
    r1 == r2 =
        rwAmount r1 == rwAmount r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerWithdrawType
    [ ('ValidatorRedeemerWithdrawType, 0)
    ]

--------------------------------------------------------------------------------2

newtype ValidatorRedeemerSellType
    = ValidatorRedeemerSellType { rcpcAmount :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerSellType where
    {-# INLINEABLE (==) #-}
    r1 == r2 =
        rcpcAmount r1 == rcpcAmount r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerSellType
    [ ('ValidatorRedeemerSellType, 0)
    ]

--------------------------------------------------------------------------------2
newtype ValidatorRedeemerGetBackType
    = ValidatorRedeemerGetBackType { rcmcAmount :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerGetBackType where
    {-# INLINEABLE (==) #-}
    r1 == r2 =
        rcmcAmount r1 == rcmcAmount r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerGetBackType
    [ ('ValidatorRedeemerGetBackType, 0)
    ]

--------------------------------------------------------------------------------2

newtype ValidatorRedeemerCollectType
    = ValidatorRedeemerCollectType { rcacAmount :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerCollectType where
    {-# INLINEABLE (==) #-}
    r1 == r2 =
        rcacAmount r1 == rcacAmount r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerCollectType
    [ ('ValidatorRedeemerCollectType, 0)
    ]

--------------------------------------------------------------------------------2

data ValidatorRedeemerMergeType = ValidatorRedeemerMergeType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerMergeType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerMergeType
    [ ('ValidatorRedeemerMergeType, 0)
    ]

--------------------------------------------------------------------------------2

data ValidatorRedeemerDeleteType = ValidatorRedeemerDeleteType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerDeleteType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerDeleteType
    [ ('ValidatorRedeemerDeleteType, 0)
    ]

--------------------------------------------------------------------------------2

data ValidatorRedeemerBalanceAssetsType = ValidatorRedeemerBalanceAssetsType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerBalanceAssetsType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerBalanceAssetsType
    [ ('ValidatorRedeemerBalanceAssetsType, 0)
    ]

--------------------------------------------------------------------------------2
data ValidatorRedeemerEmergencyType = ValidatorRedeemerEmergencyType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerEmergencyType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerEmergencyType
    [('ValidatorRedeemerEmergencyType, 0)]

--------------------------------------------------------------------------------2

data ValidatorRedeemer
    = ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType
    | ValidatorRedeemerDeposit ValidatorRedeemerDepositType
    | ValidatorRedeemerWithdraw ValidatorRedeemerWithdrawType
    | ValidatorRedeemerSell ValidatorRedeemerSellType
    | ValidatorRedeemerGetBack ValidatorRedeemerGetBackType
    | ValidatorRedeemerCollect ValidatorRedeemerCollectType
    | ValidatorRedeemerMerge ValidatorRedeemerMergeType
    | ValidatorRedeemerDelete ValidatorRedeemerDeleteType
    | ValidatorRedeemerBalanceAssets ValidatorRedeemerBalanceAssetsType
    | ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemer where
    {-# INLINEABLE (==) #-}
    ValidatorRedeemerUpdateMinADA rmf1 == ValidatorRedeemerUpdateMinADA rmf2     = rmf1 == rmf2
    ValidatorRedeemerDeposit rmf1 == ValidatorRedeemerDeposit rmf2               = rmf1 == rmf2
    ValidatorRedeemerWithdraw rmcp1 == ValidatorRedeemerWithdraw rmcp2           = rmcp1 == rmcp2
    ValidatorRedeemerSell rmcp1 == ValidatorRedeemerSell rmcp2                   = rmcp1 == rmcp2
    ValidatorRedeemerGetBack rmcp1 == ValidatorRedeemerGetBack rmcp2             = rmcp1 == rmcp2
    ValidatorRedeemerCollect rmcp1 == ValidatorRedeemerCollect rmcp2             = rmcp1 == rmcp2
    ValidatorRedeemerMerge rmcp1 == ValidatorRedeemerMerge rmcp2                 = rmcp1 == rmcp2
    ValidatorRedeemerDelete rmcp1 == ValidatorRedeemerDelete rmcp2               = rmcp1 == rmcp2
    ValidatorRedeemerBalanceAssets rmcp1 == ValidatorRedeemerBalanceAssets rmcp2 = rmcp1 == rmcp2
    ValidatorRedeemerEmergency rmcp1 == ValidatorRedeemerEmergency rmcp2         = rmcp1 == rmcp2
    _ == _                                                                       = False

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemer
    [ ('ValidatorRedeemerUpdateMinADA, 0)
    , ('ValidatorRedeemerDeposit, 1)
    , ('ValidatorRedeemerWithdraw, 2)
    , ('ValidatorRedeemerSell, 3)
    , ('ValidatorRedeemerGetBack, 4)
    , ('ValidatorRedeemerCollect, 5)
    , ('ValidatorRedeemerMerge, 6)
    , ('ValidatorRedeemerDelete, 7)
    , ('ValidatorRedeemerBalanceAssets, 8)
    , ('ValidatorRedeemerEmergency, 9)
    ]

--------------------------------------------------------------------------------2

getValidatorRedeemerName :: Maybe ValidatorRedeemer -> Maybe P.String
getValidatorRedeemerName (Just (ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType))   = Just "UpdateMinADA"
getValidatorRedeemerName (Just (ValidatorRedeemerDeposit ValidatorRedeemerDepositType {}))          = Just "Deposit"
getValidatorRedeemerName (Just (ValidatorRedeemerWithdraw ValidatorRedeemerWithdrawType {}))        = Just "Withdraw"
getValidatorRedeemerName (Just (ValidatorRedeemerSell ValidatorRedeemerSellType {}))                = Just "Sell"
getValidatorRedeemerName (Just (ValidatorRedeemerGetBack ValidatorRedeemerGetBackType {}))          = Just "GetBack"
getValidatorRedeemerName (Just (ValidatorRedeemerCollect ValidatorRedeemerCollectType {}))          = Just "Collect"
getValidatorRedeemerName (Just (ValidatorRedeemerMerge ValidatorRedeemerMergeType))                 = Just "Merge"
getValidatorRedeemerName (Just (ValidatorRedeemerDelete ValidatorRedeemerDeleteType))               = Just "Delete"
getValidatorRedeemerName (Just (ValidatorRedeemerBalanceAssets ValidatorRedeemerBalanceAssetsType)) = Just "BalanceAssets"
getValidatorRedeemerName (Just (ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType))         = Just "Emergency"
getValidatorRedeemerName _                                                                          = Nothing

--------------------------------------------------------------------------------22

mkMintIDRedeemer :: LedgerApiV2.Redeemer
mkMintIDRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerMintID PolicyRedeemerMintIDType

mkBurnIDRedeemer :: LedgerApiV2.Redeemer
mkBurnIDRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerBurnID PolicyRedeemerBurnIDType

--------------------------------------------------------------------------------2

mkUpdateMinADARedeemer :: LedgerApiV2.Redeemer
mkUpdateMinADARedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType

mkDepositRedeemer :: Integer -> LedgerApiV2.Redeemer
mkDepositRedeemer deposit' =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerDeposit $
                ValidatorRedeemerDepositType deposit'

mkWithdrawRedeemer :: Integer -> LedgerApiV2.Redeemer
mkWithdrawRedeemer withdraw' =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerWithdraw $
                ValidatorRedeemerWithdrawType withdraw'

mkSellRedeemer :: Integer -> LedgerApiV2.Redeemer
mkSellRedeemer amount' =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerSell $
                ValidatorRedeemerSellType amount'

mkGetBackRedeemer :: Integer -> LedgerApiV2.Redeemer
mkGetBackRedeemer amount' =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerGetBack $
                ValidatorRedeemerGetBackType amount'

mkCollectRedeemer :: Integer -> LedgerApiV2.Redeemer
mkCollectRedeemer amount' =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerCollect $
                ValidatorRedeemerCollectType amount'

mkMergeRedeemer :: LedgerApiV2.Redeemer
mkMergeRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerMerge ValidatorRedeemerMergeType

mkDeleteRedeemer :: LedgerApiV2.Redeemer
mkDeleteRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerDelete ValidatorRedeemerDeleteType

mkBalanceAssetsRedeemer :: LedgerApiV2.Redeemer
mkBalanceAssetsRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerBalanceAssets ValidatorRedeemerBalanceAssetsType

mkEmergencyRedeemer :: LedgerApiV2.Redeemer
mkEmergencyRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType

--------------------------------------------------------------------------------2

====== Campaign/Helpers.hs ======

{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies        #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Campaign.Helpers where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import           PlutusTx.Prelude     hiding (unless)

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Campaign.Funds.Types as CampaignFundsT
import qualified Campaign.Types       as T
import qualified Helpers.OnChain      as OnChainHelpers
import qualified Helpers.Types        as T
import qualified Constants as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Campaign_Datum_With_NormalChanges #-}
mkUpdated_Campaign_Datum_With_NormalChanges :: T.CampaignDatumType -> [T.WalletPaymentPKH] -> LedgerApiV2.CurrencySymbol -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_NormalChanges !campaignDatum_In !admins !tokenAdminPolicy_CS =
    campaignDatum_In { T.cdAdmins = admins, T.cdTokenAdminPolicy_CS = tokenAdminPolicy_CS }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Campaign_Datum_With_MinADAChanged #-}
mkUpdated_Campaign_Datum_With_MinADAChanged :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_MinADAChanged !campaignDatum_In !newMinADA = campaignDatum_In { T.cdMinADA = newMinADA }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Campaign_Datum_With_CampaignFundsAdded #-}
mkUpdated_Campaign_Datum_With_CampaignFundsAdded :: T.CampaignDatumType -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_CampaignFundsAdded !campaignDatum_In =
    campaignDatum_In { T.cdFundsCount = T.cdFundsCount campaignDatum_In + 1, T.cdFundsIndex = T.cdFundsIndex campaignDatum_In + 1 }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Campaign_Datum_With_CampaignFundsDeleted #-}
mkUpdated_Campaign_Datum_With_CampaignFundsDeleted :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_CampaignFundsDeleted !campaignDatum_In quantity =
    campaignDatum_In { T.cdFundsCount = T.cdFundsCount campaignDatum_In - quantity }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Campaign_Datum_With_NewStatus #-}
mkUpdated_Campaign_Datum_With_NewStatus :: T.CampaignDatumType -> T.CapaignStatus -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_NewStatus !campaignDatum_In !status = campaignDatum_In { T.cdStatus = status }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Campaign_Datum_With_CampaignFundsCollected #-}
mkUpdated_Campaign_Datum_With_CampaignFundsCollected :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_CampaignFundsCollected !campaignDatum_In !amount =
    campaignDatum_In { T.cdCollectedADA = T.cdCollectedADA campaignDatum_In + amount}

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_Campaign_Datum_With_NewStatusReached #-}
mkUpdated_Campaign_Datum_With_NewStatusReached :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_NewStatusReached !campaignDatum_In !fundedADA = campaignDatum_In { T.cdStatus = T.CsReached, T.cdFundedADA = fundedADA }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_Campaign_Datum_With_NewStatusNotReached #-}
mkUpdated_Campaign_Datum_With_NewStatusNotReached :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_NewStatusNotReached !campaignDatum_In !fundedADA = campaignDatum_In { T.cdStatus = T.CsNotReached, T.cdFundedADA = fundedADA }

--------------------------------------------------------------------------------

-- {-# INLINEABLE mkUpdated_Campaign_Datum_With_MilestoneAprobed #-}
-- mkUpdated_Campaign_Datum_With_MilestoneAprobed :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
-- mkUpdated_Campaign_Datum_With_MilestoneAprobed !campaignDatum_In milestoneIndex =
--     let
--         indices = OnChainHelpers.enumFromTo 0 (length (T.cdMilestones campaignDatum_In) - 1)
--         updatedMilestones = zipWith (curry updateMilestone) indices (T.cdMilestones campaignDatum_In)
--         updateMilestone (i, milestone) = if i == milestoneIndex
--                                          then milestone { T.cmStatus = T.MsSuccess }
--                                          else milestone
--     in campaignDatum_In { T.cdMilestones = updatedMilestones }

-- --------------------------------------------------------------------------------2

-- {-# INLINEABLE mkUpdated_Campaign_Datum_With_MilestoneReprobed #-}
-- mkUpdated_Campaign_Datum_With_MilestoneReprobed :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
-- mkUpdated_Campaign_Datum_With_MilestoneReprobed !campaignDatum_In milestoneIndex =
--     let
--         indices = OnChainHelpers.enumFromTo 0 (length (T.cdMilestones campaignDatum_In) - 1)
--         updatedMilestones = zipWith (curry updateMilestone) indices (T.cdMilestones campaignDatum_In)
--         updateMilestone (i, milestone) = if i == milestoneIndex
--                                          then milestone { T.cmStatus = T.MsFailed }
--                                          else milestone
--     in campaignDatum_In { T.cdMilestones = updatedMilestones, T.cdStatus = T.CsFailedMilestone }

{-# INLINEABLE mkUpdated_Campaign_Datum_With_MilestoneAprobed #-}
mkUpdated_Campaign_Datum_With_MilestoneAprobed :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_MilestoneAprobed !campaignDatum_In milestoneIndex =
    let
        updatedMilestones = updateMilestones 0 (T.cdMilestones campaignDatum_In)
        
        updateMilestones :: Integer -> [T.CampaignMilestones] -> [T.CampaignMilestones]
        updateMilestones _ [] = []
        updateMilestones i (m : ms)
            | i == milestoneIndex = m { T.cmStatus = T.MsSuccess } : updateMilestones (i + 1) ms
            | otherwise            = m : updateMilestones (i + 1) ms
    in campaignDatum_In { T.cdMilestones = updatedMilestones }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_Campaign_Datum_With_MilestoneReprobed #-}
mkUpdated_Campaign_Datum_With_MilestoneReprobed :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_MilestoneReprobed !campaignDatum_In milestoneIndex =
    let
        updatedMilestones = updateMilestones 0 (T.cdMilestones campaignDatum_In)
        
        updateMilestones :: Integer -> [T.CampaignMilestones] -> [T.CampaignMilestones]
        updateMilestones _ [] = []
        updateMilestones i (m : ms)
            | i == milestoneIndex = m { T.cmStatus = T.MsFailed } : updateMilestones (i + 1) ms
            | otherwise            = m : updateMilestones (i + 1) ms
    in campaignDatum_In { T.cdMilestones = updatedMilestones, T.cdStatus = T.CsFailedMilestone }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_Campaign_Datum_With_Collect #-}
mkUpdated_Campaign_Datum_With_Collect :: T.CampaignDatumType -> Integer -> T.CampaignDatumType
mkUpdated_Campaign_Datum_With_Collect !campaignDatum_In !amount =
    campaignDatum_In {
        T.cdCollectedADA = T.cdCollectedADA campaignDatum_In + amount
        }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_MergedSubtotals #-}
mkUpdated_CampaignFunds_Datum_With_MergedSubtotals :: CampaignFundsT.CampaignFundsDatumType -> Integer ->  Integer -> Integer ->  Integer ->  Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_MergedSubtotals !campaignFundsDatum_Out !avalaible_CampaignToken !sold_CampaignToken !avalaible_ADA !collected_ADA !minADA  =
    campaignFundsDatum_Out {
        CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken = avalaible_CampaignToken ,
        CampaignFundsT.cfdSubtotal_Sold_CampaignToken = sold_CampaignToken,
        CampaignFundsT.cfdSubtotal_Avalaible_ADA = avalaible_ADA ,
        CampaignFundsT.cfdSubtotal_Collected_ADA = collected_ADA ,
        CampaignFundsT.cfdMinADA = minADA}

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_MinADAChanged #-}
mkUpdated_CampaignFunds_Datum_With_MinADAChanged :: CampaignFundsT.CampaignFundsDatumType -> Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_MinADAChanged !campaignFundsDatum_In !newMinADA = campaignFundsDatum_In { CampaignFundsT.cfdMinADA = newMinADA }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_Deposits #-}
mkUpdated_CampaignFunds_Datum_With_Deposits :: CampaignFundsT.CampaignFundsDatumType -> Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_Deposits !campaignFundsDatum_In !amount =
    campaignFundsDatum_In {
        CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken = CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken campaignFundsDatum_In + amount
        }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_Withdraw #-}
mkUpdated_CampaignFunds_Datum_With_Withdraw :: CampaignFundsT.CampaignFundsDatumType -> Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_Withdraw !campaignFundsDatum_In !amount =
    campaignFundsDatum_In {
        CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken = CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken campaignFundsDatum_In - amount
        }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_SoldTokens #-}
mkUpdated_CampaignFunds_Datum_With_SoldTokens :: CampaignFundsT.CampaignFundsDatumType -> Integer -> Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_SoldTokens !campaignFundsDatum_In  !amount_CampaignToken !amount_ADA =
    campaignFundsDatum_In {
        CampaignFundsT.cfdSubtotal_Sold_CampaignToken = CampaignFundsT.cfdSubtotal_Sold_CampaignToken campaignFundsDatum_In + amount_CampaignToken,
        CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken = CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken campaignFundsDatum_In - amount_CampaignToken ,
        CampaignFundsT.cfdSubtotal_Avalaible_ADA = CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken campaignFundsDatum_In + amount_ADA
        }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_GetBackTokens #-}
mkUpdated_CampaignFunds_Datum_With_GetBackTokens :: CampaignFundsT.CampaignFundsDatumType -> Integer -> Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_GetBackTokens !campaignFundsDatum_In !amount_CampaignToken !amount_ADA =
    campaignFundsDatum_In {
        CampaignFundsT.cfdSubtotal_Sold_CampaignToken = CampaignFundsT.cfdSubtotal_Sold_CampaignToken campaignFundsDatum_In - amount_CampaignToken,
        CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken = CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken campaignFundsDatum_In + amount_CampaignToken ,
        CampaignFundsT.cfdSubtotal_Avalaible_ADA = CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken campaignFundsDatum_In - amount_ADA
        }

--------------------------------------------------------------------------------

{-# INLINEABLE mkUpdated_CampaignFunds_Datum_With_Collect #-}
mkUpdated_CampaignFunds_Datum_With_Collect :: CampaignFundsT.CampaignFundsDatumType -> Integer -> CampaignFundsT.CampaignFundsDatumType
mkUpdated_CampaignFunds_Datum_With_Collect !campaignFundsDatum_In !amount =
    campaignFundsDatum_In {
        CampaignFundsT.cfdSubtotal_Avalaible_ADA = CampaignFundsT.cfdSubtotal_Avalaible_ADA campaignFundsDatum_In - amount
        , CampaignFundsT.cfdSubtotal_Collected_ADA = CampaignFundsT.cfdSubtotal_Collected_ADA campaignFundsDatum_In + amount
        }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkCampaignFundsID_TN #-}
mkCampaignFundsID_TN :: Integer -> LedgerApiV2.TokenName
mkCampaignFundsID_TN index =
    LedgerApiV2.TokenName $ T.campaignFundsID_TN_basename <> OnChainHelpers.intToBBS index

--------------------------------------------------------------------------------


====== Campaign/OnChain.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:dump-uplc #-}
--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
{- HLINT ignore "Reduce duplication"          -}
--------------------------------------------------------------------------------2

module Campaign.OnChain where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Ledger
import qualified Ledger.Ada                as LedgerAda
import qualified Ledger.Value              as LedgerValue
import qualified Plutonomy
import qualified Plutus.V2.Ledger.Api      as LedgerApiV2
import qualified Plutus.V2.Ledger.Contexts as LedgerContextsV2
import qualified PlutusTx
import           PlutusTx.Prelude

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Campaign.Funds.Types      as CampaignFundsT
import qualified Campaign.Helpers          as CampaignHelpers
import qualified Campaign.Types            as T
import qualified Constants                 as T
import qualified Helpers.OnChain           as OnChainHelpers
import           Prelude                   (Show)
import qualified Protocol.Types            as ProtocolT
import qualified Types                     as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

--------------------------------------------------------------------------------
-- Validator Types and Context
--------------------------------------------------------------------------------

data ValidationParams
    = ValidationParams
          { vParams        :: !T.ValidatorParams
          , vCtx           :: !LedgerContextsV2.ScriptContext
          , vInfo          :: !LedgerContextsV2.TxInfo
          , vRedeemer      :: !T.ValidatorRedeemer
          , vDatum         :: !T.CampaignDatumType
          , vOwnInput      :: !LedgerContextsV2.TxOut
          , vOwnAddress    :: !LedgerApiV2.Address
          , vInputValue    :: !Ledger.Value
          , vCampaignID_AC :: !LedgerValue.AssetClass
          , vProtocolID_AC :: !LedgerValue.AssetClass
          }
    deriving (Show)

{-# INLINEABLE mkValidator #-}
mkValidator :: T.ValidatorParams -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkValidator !params !datumRaw !redRaw !ctxRaw =
    let !vp = mkValidationParams params datumRaw redRaw ctxRaw
    in if traceIfFalse "not unique" (checkUnique vp)
          && validate vp
       then ()
       else error ()

{-# INLINEABLE mkValidationParams #-}
mkValidationParams :: T.ValidatorParams -> BuiltinData -> BuiltinData -> BuiltinData -> ValidationParams
mkValidationParams !params !datumRaw !redRaw !ctxRaw =
    let !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.ValidatorRedeemer redRaw
        !datum = T.getCampaign_DatumType $ LedgerApiV2.unsafeFromBuiltinData @T.ValidatorDatum datumRaw
        !ownInput = OnChainHelpers.getUnsafe_Own_Input_TxOut ctx
        !ownAddress = LedgerApiV2.txOutAddress ownInput
        !campaignPolicy_CS = T.cdCampaignPolicy_CS datum
        !protocolPolicyID = T.vpProtocolPolicyID_CS params
    in ValidationParams
        { vParams = params
        , vCtx = ctx
        , vInfo = info
        , vRedeemer = redeemer
        , vDatum = datum
        , vOwnInput = ownInput
        , vOwnAddress = ownAddress
        , vInputValue = LedgerApiV2.txOutValue ownInput
        , vCampaignID_AC = LedgerValue.AssetClass (campaignPolicy_CS, T.campaignID_TN)
        , vProtocolID_AC = LedgerValue.AssetClass (protocolPolicyID, T.protocolID_TN)
        }

--------------------------------------------------------------------------------
-- Primary Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE checkUnique #-}
checkUnique :: ValidationParams -> Bool
checkUnique !vp = T.vpProtocolPolicyID_CS (vParams vp) /= LedgerApiV2.adaSymbol

{-# INLINEABLE validate #-}
validate :: ValidationParams -> Bool
validate !vp = case vRedeemer vp of
    T.ValidatorRedeemerEmergency _ -> validateEmergency vp
    _                              -> validateNonEmergency vp

{-# INLINEABLE validateEmergency #-}
validateEmergency :: ValidationParams -> Bool
validateEmergency !vp =
    let !tokenEmergencyAdmin_AC = LedgerValue.AssetClass (T.vpTokenEmergencyAdminPolicy_CS $ vParams vp, T.tokenEmergencyAdmin_TN)
        !outputs = LedgerApiV2.txInfoOutputs $ vInfo vp
    in traceIfFalse "not isEmergencyAdminTokenPresent" $
       not (null outputs) && OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue $ head outputs) tokenEmergencyAdmin_AC

{-# INLINEABLE validateNonEmergency #-}
validateNonEmergency :: ValidationParams -> Bool
validateNonEmergency !vp =
    traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange (vInfo vp) T.validTxTimeRange)
        && validateByInputOutput vp

--------------------------------------------------------------------------------
-- Input/Output Processing
--------------------------------------------------------------------------------

{-# INLINEABLE validateByInputOutput #-}
validateByInputOutput :: ValidationParams -> Bool
validateByInputOutput !vp =
    let !ownInputs = getOwnInputs vp
        !ownOutputs = getOwnOutputs vp
        !hasOneInput = length ownInputs == 1
        !hasNoOutputs = null ownOutputs
        !hasOneOutput = length ownOutputs == 1
    in if hasOneInput && hasNoOutputs
        then validateSingleInputNoOutput vp
        else if hasOneInput && hasOneOutput
            then validateSingleInputSingleOutput vp
            else traceError "Invalid input/output combination"

{-# INLINEABLE validateSingleInputNoOutput #-}
validateSingleInputNoOutput :: ValidationParams -> Bool
validateSingleInputNoOutput !vp =
    case vRedeemer vp of
        T.ValidatorRedeemerDelete _ -> validateDelete vp
        _                           -> False

{-# INLINEABLE validateSingleInputSingleOutput #-}
validateSingleInputSingleOutput :: ValidationParams -> Bool
validateSingleInputSingleOutput !vp =
    case getOutput_Campaign_DatumAndValue vp of
        Nothing                     -> traceError "Expected Campaign at output"
        Just (!outDatum, !outValue) -> validateRedeemer vp outDatum outValue

{-# INLINEABLE validateRedeemer #-}
validateRedeemer :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Bool
validateRedeemer !vp !outDatum !outValue = case vRedeemer vp of
    T.ValidatorRedeemerDatumUpdate _          -> validateUpdate vp outDatum outValue
    T.ValidatorRedeemerUpdateMinADA _         -> validateMinADAUpdate vp outDatum outValue
    T.ValidatorRedeemerFundsAdd _             -> validateFundsAdd vp outDatum outValue
    T.ValidatorRedeemerFundsMerge _           -> validateFundsMergeAndDelete vp outDatum outValue
    T.ValidatorRedeemerFundsDelete _          -> validateFundsMergeAndDelete vp outDatum outValue
    T.ValidatorRedeemerInitializeCampaign _   -> validateStatusUpdate vp outDatum outValue
    T.ValidatorRedeemerReachedCampaign _      -> validateStatusUpdate vp outDatum outValue
    T.ValidatorRedeemerNotReachedCampaign _   -> validateStatusUpdate vp outDatum outValue
    r@(T.ValidatorRedeemerMilestoneAprobe _)  -> validateMilestone vp outDatum outValue r
    r@(T.ValidatorRedeemerMilestoneReprobe _) -> validateMilestone vp outDatum outValue r
    T.ValidatorRedeemerFundsCollect params    -> validateFundsCollect vp outDatum outValue params
    _                                         -> False


--------------------------------------------------------------------------------
--  Update Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateUpdate #-}
validateUpdate :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Bool
validateUpdate !vp !outDatum !outValue =
    ---------------------
    -- it runs alone
    ---------------------
    -- solo es posible actualizar admin y token admin
    -- Que sea Protocol or Campaign Admin
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- no hay restricciones temporales
    ---------------------
    validateProtocolOrCampaignAdmin vp
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Updated"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_NormalChanges
                (vDatum vp)
                (T.cdAdmins outDatum)
                (T.cdTokenAdminPolicy_CS outDatum))
        && validateValueNotChanged vp outValue

--------------------------------------------------------------------------------
-- MinADA Update Implementation
--------------------------------------------------------------------------------

{-# INLINEABLE validateMinADAUpdate #-}
validateMinADAUpdate :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Bool
validateMinADAUpdate !vp !outDatum !outValue =
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol or Campaign Admin
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignDatum se actualiza correctamente
    -- Que el CampaignDatum value cambie con el min ADA nuevo
    -- no hay restricciones temporales
    ------------------
    validateProtocolOrCampaignAdmin vp
        && traceIfFalse "not min ADA > 0" (newMinADA > 0)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_UpdatedMinADA"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_MinADAChanged (vDatum vp) newMinADA)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_Changed" (outValue `OnChainHelpers.isEqValue` (vInputValue vp <> LedgerAda.lovelaceValueOf adaChange))
    where
        !newMinADA = T.cdMinADA outDatum
        !adaChange = newMinADA - T.cdMinADA (vDatum vp)


--------------------------------------------------------------------------------
-- Funds Management Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateFundsAdd #-}
validateFundsAdd :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Bool
validateFundsAdd !vp !outDatum !outValue =
    ------------------
    -- it runs along with CampaignFunds ID Policy (PolicyRedeemerMintID)
    ------------------
    -- Que sea Protocol or Campaign Admin
    -- Que se mintee CampaignFunds ID con la correcta póliza indicada en CampaignDatum
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignDatum se actualiza con nuevo Campaign Funds
    -- Que el CampaignDatum value no cambie
    -- el datum Campaign Funds y la direccion a donde va estara controlado por la poliza Campaign Funds, que ya me aseguro que se ejecuta el controlar que se este minteando CampaignFunds ID
    -- no hay restricciones temporales
    -- que la poliza de Campaign Funds controle el mint de este NFT y controle el CampaignFundsDatum
    ------------------
    let !fundsPolicyCS = T.cdCampaignFundsPolicyID_CS $ vDatum vp
    in traceIfFalse "not validateProtocolOrCampaignAdminAction"
        (validateProtocolOrCampaignAdmin vp)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_With_CampaignFundsAdded"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_CampaignFundsAdded (vDatum vp))
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged"
            (validateValueNotChanged vp outValue)
        && traceIfFalse "not isMintingCampaignFundsID"
            (OnChainHelpers.isNFT_Minting_With_CS fundsPolicyCS (vInfo vp))

{-# INLINEABLE validateFundsMergeAndDelete #-}
validateFundsMergeAndDelete :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Bool
validateFundsMergeAndDelete !vp !outDatum !outValue =
     ------------------
    -- 1 - it runs along Campaign Validator, one input, one output (ValidatorRedeemerFundsDelete or ValidatorRedeemerFundsMerge)
    -- 2 - it runs along Campaign Funds ID Policy (PolicyRedeemerBurnID)
    -- 3 - it runs along Campaign Funds Validator, many inputs-one output (ValidatorRedeemerMerge) or many inputs-zero outputs (ValidatorRedeemerDelete)
    ------------------
    -- 1 - Que sea Protocol or Campaig Admin
    -- 1 - Que se quemen CampaignFundsIDs con la correcta póliza CS indicada en CampaignDatum
    -- 1 - Que el CampaignDatum regrese a Campaign Validator (se hace automaticamente al buscar outputs en same address)
    -- 1 - Que el CampaignDatum se actualiza con el Campaign Funds eliminados
    -- 1 - Que el CampaignDatum value no cambie
    -- 2 - Que se quemen CampaignFundsIDs con own póliza
    -- 2 - Que coincida exactamente el total minted con el quantity del redeemer de Campaign Validator (en caso de Merge quantity menos uno)
    -- 2 - Que coincida exactamente el total minted con la cantidad de inputs de Campaign Funds Validator (en caso de Merge hay una input que no se quema)
    -- 2 - que el redeemer de Campaign validator sea correcto
    -- 2 - que el redeemer de todos los Campaign Funds Validator sea correcto
    -- 3 - Que se quemen CampaignFundsIDs con la correcta póliza CS indicada en CampaignFundDatum
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante regrese a Campaign Funds Validator (se hace automaticamente al buscar outputs en same address)
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga el value de todos acumulados
    -- 3 - En el caso de Merge: Que el CampaignFundsDatum resultante tenga en el datum los subtotales acumulados
    -- 3 - En el caso de Delete: que los CampaignFundsDatum no tengan tokens en value
    -- 3 - En el caso de Delete: que los CampaignFundsDatum tengan zero subtotales
    ------------------
    -- no hay restricciones temporales
    ------------------
    case vRedeemer vp of
        T.ValidatorRedeemerFundsMerge (T.ValidatorRedeemerFundsMergeType !qty) ->
            validateFundsOperation (qty - 1)
        T.ValidatorRedeemerFundsDelete (T.ValidatorRedeemerFundsDeleteType !qty) ->
            validateFundsOperation qty
        _ -> False
    where
        validateFundsOperation :: Integer -> Bool
        validateFundsOperation  !qty =
            let !fundsPolicyCS = T.cdCampaignFundsPolicyID_CS $ vDatum vp
            in traceIfFalse "not validateProtocolOrCampaignAdminAction"
                (validateProtocolOrCampaignAdmin vp)
                && traceIfFalse "not isCorrect_Output_Campaign_Datum_With_CampaignFundsDeleted"
                    (outDatum `OnChainHelpers.isUnsafeEqDatums`
                    CampaignHelpers.mkUpdated_Campaign_Datum_With_CampaignFundsDeleted (vDatum vp) qty)
                && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged"
                    (validateValueNotChanged vp outValue)
                && traceIfFalse "not isBurningCampaignFundsIDs"
                    (OnChainHelpers.isToken_Burning_With_CS_AndAmt fundsPolicyCS qty (vInfo vp))

--------------------------------------------------------------------------------
-- Milestone Management Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateMilestone #-}
validateMilestone :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> T.ValidatorRedeemer -> Bool
validateMilestone !vp !outDatum !outValue !redeemer =
    ---------------------
    -- it runs alone
    ---------------------
    -- solo es posible actualizar admin y token admin
    -- Que sea Protocol Admin
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- que este en status CsReached
    -- que el milestone anterior este en status MsSuccess
    -- que el nuevo milestone actual este en status MsCreated
    ---------------------
    let !milestoneIndex = case redeemer of
            T.ValidatorRedeemerMilestoneAprobe (T.ValidatorRedeemerMilestoneAprobeType idx)   -> idx
            T.ValidatorRedeemerMilestoneReprobe (T.ValidatorRedeemerMilestoneReprobeType idx) -> idx
            _                                                                                 -> traceError "Invalid milestone redeemer"
        !protocolDatum = getProtocol_Datum vp
    in validateProtocolAdminAction vp protocolDatum
        && traceIfFalse "not isCorrectRedeemerMilestoneIndex" (isValidMilestoneIndex vp milestoneIndex)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Updated"
            (validateMilestoneDatumUpdate vp outDatum milestoneIndex redeemer)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged"
            (validateValueNotChanged vp outValue)
        && traceIfFalse "not isCampaignReached"
            (T.cdStatus (vDatum vp) == T.CsReached)
        && traceIfFalse "not isPreviusMilestoneAprobed"
            (validatePreviousMilestone vp milestoneIndex)
        && traceIfFalse "not isCurrentMilestoneCreated"
            (validateCurrentMilestone vp milestoneIndex)

{-# INLINEABLE isValidMilestoneIndex #-}
isValidMilestoneIndex :: ValidationParams -> Integer -> Bool
isValidMilestoneIndex !vp !idx =
    let !milestones = T.cdMilestones $ vDatum vp
        !len = length milestones
    in idx >= 0 && idx < len

{-# INLINEABLE validateMilestoneDatumUpdate #-}
validateMilestoneDatumUpdate :: ValidationParams -> T.CampaignDatumType -> Integer -> T.ValidatorRedeemer -> Bool
validateMilestoneDatumUpdate !vp !outDatum !idx !redeemer =
    case redeemer of
        T.ValidatorRedeemerMilestoneAprobe _ ->
            outDatum `OnChainHelpers.isUnsafeEqDatums`
            CampaignHelpers.mkUpdated_Campaign_Datum_With_MilestoneAprobed (vDatum vp) idx
        T.ValidatorRedeemerMilestoneReprobe _ ->
            outDatum `OnChainHelpers.isUnsafeEqDatums`
            CampaignHelpers.mkUpdated_Campaign_Datum_With_MilestoneReprobed (vDatum vp) idx
        _ -> False

{-# INLINEABLE validatePreviousMilestone #-}
validatePreviousMilestone :: ValidationParams -> Integer -> Bool
validatePreviousMilestone !vp !idx
    | idx == 0 = True
    | otherwise =
        let !milestones = T.cdMilestones $ vDatum vp
            !prevMilestone = milestones !! (idx - 1)
        in T.cmStatus prevMilestone == T.MsSuccess

{-# INLINEABLE validateCurrentMilestone #-}
validateCurrentMilestone :: ValidationParams -> Integer -> Bool
validateCurrentMilestone !vp !idx =
    let !milestones = T.cdMilestones $ vDatum vp
        !milestone = milestones !! idx
    in T.cmStatus milestone == T.MsCreated

--------------------------------------------------------------------------------
-- Collection Management Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateFundsCollect #-}
validateFundsCollect :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> T.ValidatorRedeemerFundsCollectType -> Bool
validateFundsCollect !vp !outDatum !outValue (T.ValidatorRedeemerFundsCollectType !amount) =
    ---------------------
    -- 1 - it runs along Campaign Validator, one input, one output (ValidatorRedeemerFundsCollect)
    -- 2 - it runs along Campaign Funds Validator, one input, one output (ValidatorRedeemerCollect)
    ------------------
    -- 1 - Que sea Campaign Admin
    -- 1 - Que el CampaignDatum regrese a Campaign Validator (se hace automaticamente al buscar outputs en same address)
    -- 1 - Que el CampaignDatum este en estado CsReached
    -- 1 - Que el CampaignDatum se actualiza con el pago a los creadores de la campaña
    -- 1 - Que el CampaignDatum value no cambie
    -- 1 - que el redeemer de todos los Campaign Funds Validator sea correcto, mismo redeemer type, misma date, mismo amount.
    -- 1 - Que el monto no supera lo disponible en ese momento: el pago total acumulado hasta ahora menos lo cobrado.
    -- 1 - El pago acumulado hasta ahora es de acuerdo al ultimo milestone aprobado. Siempre que el ultimo milestone estuvira en Creado y no en Fallado.
    -- 1 - Cada milestone establece un porcentaje del total. Tengo el campo de total vendido ADA, y de ahi calculo los porcentajes.
    -- 2 - que el redeemer de Campaign validator sea correcto
    -- 2 - Que todos los CampaignFundsDatum resultantes regrese a Campaign Funds Validator (se hace automaticamente al buscar outputs en same address)
    -- 2 - Que los CampaignFundsDatum datums se actualicen correctamente: solo el campo collected debe modificarse, sumando algun valor.
    -- 2 - Que la suma de todo lo que se saca de cada uno, coincida con amount
    -- 2 - Que los CampaignFundsDatum tengan values actualizados: con menos ADA. Cada uno coincidiendo con el valor de collected del datum
    ------------------
    -- no hay restricciones temporales
    ------------------
    traceIfFalse "not validateCampaignAdminAction" (validateCampaignAdminAction vp)
        && traceIfFalse "not isCampaignStatus CsReached" (isCampaignStatus vp T.CsReached)
        && traceIfFalse "not amount_ADA > 0" (amount > 0)
        && traceIfFalse "not avalaible_ADA_to_Collect >= amount_ADA" (getAvailableADA vp >= amount)
        && traceIfFalse "not isCorrectRedeemersCampaignFundsDatum" (validateCampaignFundsRedeemers vp amount)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Updated_With_Collect"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_CampaignFundsCollected (vDatum vp) amount)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged"
            (validateValueNotChanged vp outValue)

{-# INLINEABLE getAvailableADA #-}
getAvailableADA :: ValidationParams -> Integer
getAvailableADA !vp =
    let 
        findCurrentMilestoneIndex :: Integer
        findCurrentMilestoneIndex =
            let !searchIndex = go 0 milestones
                go !idx [] = idx
                go !idx (m:ms)
                    | T.cmStatus m /= T.MsSuccess = idx
                    | otherwise = go (idx + 1) ms
            in searchIndex
        
        calculateAvailableAmount :: Integer -> Integer
        calculateAvailableAmount !currentIdx
            | currentIdx >= length milestones = 0
            | otherwise =
                let !milestone = milestones !! currentIdx
                in case T.cmStatus milestone of
                    T.MsCreated ->
                        let !percentage = calculatePercentage currentIdx
                        in percentage * fundedADA `divide` 100
                    _ -> 0

        calculatePercentage :: Integer -> Integer
        calculatePercentage !idx
            | idx >= length milestones - 1 = 100
            | otherwise = go 0 0
            where
                go !acc !i
                    | i > idx = acc
                    | otherwise = go (acc + T.cmPerncentage (milestones !! i)) (i + 1)

        !datum = vDatum vp
        !fundedADA = T.cdFundedADA datum
        !collectedADA = T.cdCollectedADA datum
        !milestones = T.cdMilestones datum
        !currentMilestoneIndex = findCurrentMilestoneIndex
        !availableAmount = calculateAvailableAmount currentMilestoneIndex

    in availableAmount - collectedADA

{-# INLINEABLE validateCampaignFundsRedeemers #-}
validateCampaignFundsRedeemers :: ValidationParams -> Integer -> Bool
validateCampaignFundsRedeemers !vp !amount =
    let !fundsPolicyCS = T.cdCampaignFundsPolicyID_CS $ vDatum vp
        !inputs = [(LedgerApiV2.txInInfoOutRef txIn, LedgerApiV2.txInInfoResolved txIn)
                | txIn <- LedgerApiV2.txInfoInputs $ vInfo vp]
        !campaignFundsInput = case OnChainHelpers.getTxOutRefs_TxOuts_And_DatumTypes_From_TxOutRefs_TxOuts_By_CS
            @CampaignFundsT.ValidatorDatum
            @CampaignFundsT.CampaignFundsDatumType
            (vCtx vp)
            inputs
            fundsPolicyCS
            CampaignFundsT.getCampaignFunds_DatumType of
                [x] -> x
                _   -> traceError "Expected one CampaignFunds input"
    in  case OnChainHelpers.getRedeemerForConsumeInput ((\(txOutRef, _, _) -> txOutRef) campaignFundsInput) (vInfo vp) of
        Nothing -> traceError "Expected CampaignFunds input with redeemers"
        Just !r -> case LedgerApiV2.fromBuiltinData @CampaignFundsT.ValidatorRedeemer $ LedgerApiV2.getRedeemer r of
            Just (CampaignFundsT.ValidatorRedeemerCollect (CampaignFundsT.ValidatorRedeemerCollectType !amount')) ->
                amount == amount'
            _ -> traceError "Expected CampaignFunds input with valid redeemer ValidatorRedeemerCollect"

--------------------------------------------------------------------------------
-- Status Update Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateStatusUpdate #-}
validateStatusUpdate :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Bool
validateStatusUpdate !vp !outDatum !outValue =
    let !protocolDatum = getProtocol_Datum vp
        !campaignFundsDatum = snd <$> getCampaignFunds vp
    in case vRedeemer vp of 
        T.ValidatorRedeemerInitializeCampaign _ -> validateInitialize vp outDatum outValue protocolDatum campaignFundsDatum
        T.ValidatorRedeemerReachedCampaign _    -> validateReached vp outDatum outValue protocolDatum campaignFundsDatum
        T.ValidatorRedeemerNotReachedCampaign _ -> validateNotReached vp outDatum outValue protocolDatum campaignFundsDatum
        _                                       -> False

{-# INLINEABLE validateInitialize #-}
validateInitialize :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Maybe ProtocolT.ProtocolDatumType -> [CampaignFundsT.CampaignFundsDatumType] -> Bool
validateInitialize !vp !outDatum !outValue !mProtocolDatum !campaignFundsDatum =
     ---------------------
    -- Inicializa la campaña, una vez que tiene los fondos a la venta necesarios
    -- Deben haber sido minteados antes y agregados a las UTXO de fondos
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol Admin
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignDatum value no cambie
    -- tiene que estar en estado created
    -- tiene que tener en los CampaignFunds la cantidad de tokens necesarias para poner a la venta (el max requested)
    ---------------------
    validateProtocolAdminAction vp mProtocolDatum
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Updated"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_NewStatus (vDatum vp) T.CsInitialized)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged" (validateValueNotChanged vp outValue)
        && traceIfFalse "not isCampaignStatusCreated" (isCampaignStatus vp T.CsCreated)
        && traceIfFalse "not isAllCampaignFunds" (length campaignFundsDatum == T.cdFundsCount (vDatum vp))
        && traceIfFalse "not isCampaignTokensAvalaible" isCampaignTokensAvalaible
    where
        isCampaignTokensAvalaible :: Bool
        !isCampaignTokensAvalaible =
            let
                requestedMaxADA = T.cdRequestedMaxADA (vDatum vp)
                requestedTokensToSell = requestedMaxADA `divide` T.cdCampaignToken_PriceADA (vDatum vp)
                tokensAvalaibles = sum (CampaignFundsT.cfdSubtotal_Avalaible_CampaignToken <$> campaignFundsDatum)
            in
                requestedTokensToSell == tokensAvalaibles

{-# INLINEABLE validateReached #-}
validateReached :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Maybe ProtocolT.ProtocolDatumType -> [CampaignFundsT.CampaignFundsDatumType] -> Bool
validateReached !vp !outDatum !outValue !mProtocolDatum !campaignFundsDatum =
    ---------------------
    -- Cambia el estado de campaña a alcanzada
    -- Deben haber sido vendidos la cantidad minima de tokens por lo menos
    -- Debe estar en estado inicalizada
    -- Debe estar en fecha de deadline pasado
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol Admin
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignDatum value no cambie
    -- Que se actualice la cantidad de ADA recivida (fundedADA) y el nuevo estado cSReached
    -- tiene que estar en estado CsInitialized
    -- tiene que tener en los CampaignFunds la cantidad de tokens necesarias vendidos, superando el minimo esperado
    -- que haya terminado la campaña
    ---------------------
        validateProtocolAdminAction vp mProtocolDatum
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Updated"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_NewStatusReached (vDatum vp) tokensToSold)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged" (validateValueNotChanged vp outValue)
        && traceIfFalse "not isCampaignStatusInitialized" (isCampaignStatus vp T.CsInitialized)
        && traceIfFalse "not isAllCampaignFunds" (length campaignFundsDatum == T.cdFundsCount (vDatum vp))
        && traceIfFalse "not isCampaignFundsTokensSold" isCampaignFundsTokensSold
        && traceIfFalse "not isCampaignFinish" (isCampaignFinish vp)
    where
         ---------------------
        !tokensToSold = sum (CampaignFundsT.cfdSubtotal_Sold_CampaignToken <$> campaignFundsDatum)
        ---------------------
        isCampaignFundsTokensSold :: Bool
        !isCampaignFundsTokensSold =
            let
                !requestedMinADA = T.cdRequestedMinADA (vDatum vp)
            in
                requestedMinADA <= tokensToSold * T.cdCampaignToken_PriceADA (vDatum vp)


{-# INLINEABLE validateNotReached #-}
validateNotReached :: ValidationParams -> T.CampaignDatumType -> Ledger.Value -> Maybe ProtocolT.ProtocolDatumType -> [CampaignFundsT.CampaignFundsDatumType] -> Bool
validateNotReached !vp !outDatum !outValue !mProtocolDatum !campaignFundsDatum =
    ---------------------
    -- Cambia el estado de campaña a no alcanzada
    -- Deben haber sido vendidos menos de la cantidad minima de tokens
    -- Debe estar en estado inicalizada
    -- Debe estar en fecha de deadline pasado
    ---------------------
    -- it runs alone
    ---------------------
    -- Que sea Protocol Admin
    -- Que el CampaignDatum regrese a Campaign Val (se hace automaticamente al buscar outputs en same address)
    -- Que el CampaignDatum value no cambie
    -- Que se actualice la cantidad de ADA recivida (fundedADA) y el nuevo estado cSNotReached
    -- tiene que estar en estado CsInitialized
    -- tiene que no tener en los CampaignFunds la cantidad de tokens minimos
    -- la fecha tiene que haber pasado al deadline
    ---------------------
        validateProtocolAdminAction vp mProtocolDatum
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Updated"
            (outDatum `OnChainHelpers.isUnsafeEqDatums`
             CampaignHelpers.mkUpdated_Campaign_Datum_With_NewStatusNotReached (vDatum vp) tokensToSold)
        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged" (validateValueNotChanged vp outValue)
        && traceIfFalse "not isCampaignStatusInitialized" (isCampaignStatus vp T.CsInitialized)
        && traceIfFalse "not isAllCampaignFunds" (length campaignFundsDatum == T.cdFundsCount (vDatum vp))
        && traceIfFalse "not isCampaignFundsTokensNotSold" isCampaignFundsTokensNotSold
        && traceIfFalse "not isCampaignFinish" (isCampaignFinish vp)
    where
        ---------------------
        !tokensToSold = sum (CampaignFundsT.cfdSubtotal_Sold_CampaignToken <$> campaignFundsDatum)
        ---------------------
        isCampaignFundsTokensNotSold :: Bool
        !isCampaignFundsTokensNotSold =
            let
                !requestedMinADA = T.cdRequestedMinADA (vDatum vp)
            in
                requestedMinADA > tokensToSold * T.cdCampaignToken_PriceADA (vDatum vp)

--------------------------------------------------------------------------------
-- Delete Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE validateDelete #-}
validateDelete :: ValidationParams -> Bool
validateDelete !vp =
     ------------------
    -- it runs along with Campaign ID Policy  (PolicyRedeemerBurnID)
    ------------------
    -- Que sea Protocol Admin
    -- que el Campaign tenga CERO CampaignFunds
    -- Que se quemen los Campaign ID con la correcta póliza indicada en CampaignDatum siendo consumido
    ------------------
    let !protocolDatum = getProtocol_Datum vp
    in validateProtocolAdminAction vp protocolDatum
        && traceIfFalse "not isBurningCampaignID" (OnChainHelpers.isNFT_Burning_With_AC (vCampaignID_AC vp) (vInfo vp))
        && traceIfFalse "not isZeroCampaignFunds" (T.cdFundsCount (vDatum vp) == 0)


--------------------------------------------------------------------------------
-- Helper Functions
--------------------------------------------------------------------------------

{-# INLINEABLE getOwnInputs #-}
getOwnInputs :: ValidationParams -> [LedgerContextsV2.TxOut]
getOwnInputs !vp  =
    [ LedgerApiV2.txInInfoResolved txInfoInput
    | txInfoInput <- LedgerApiV2.txInfoInputs $ vInfo vp
    , let address = LedgerApiV2.txOutAddress (LedgerApiV2.txInInfoResolved txInfoInput)
    , OnChainHelpers.isScriptAddress address && address == vOwnAddress vp
    ]

{-# INLINEABLE getOwnOutputs #-}
getOwnOutputs :: ValidationParams -> [LedgerContextsV2.TxOut]
getOwnOutputs !vp =
    [ output
    | output <- LedgerApiV2.txInfoOutputs $ vInfo vp
     , let address = LedgerApiV2.txOutAddress output
    , OnChainHelpers.isScriptAddress address && LedgerApiV2.txOutAddress output == address
    ]

{-# INLINEABLE getRefInputs #-}
getRefInputs :: ValidationParams -> [LedgerContextsV2.TxOut]
getRefInputs !vp =
    [ LedgerApiV2.txInInfoResolved txInfoInput
    | txInfoInput <- LedgerApiV2.txInfoReferenceInputs $ vInfo vp
    , OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress $ LedgerApiV2.txInInfoResolved txInfoInput)
    ]

{-# INLINEABLE getProtocol_Datum #-}
getProtocol_Datum :: ValidationParams -> Maybe ProtocolT.ProtocolDatumType
getProtocol_Datum !vp =
    let !refInputs = getRefInputs vp
        !protocolDatums = OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_AC
            (vCtx vp)
            refInputs
            (vProtocolID_AC vp)
            ProtocolT.getProtocol_DatumType
    in case protocolDatums of
        [(_,x)] -> Just x
        _   -> Nothing

{-# INLINEABLE getCampaignFunds #-}
getCampaignFunds :: ValidationParams -> [(LedgerContextsV2.TxOut, CampaignFundsT.CampaignFundsDatumType)] 
getCampaignFunds !vp  =
    let !refInputs = getRefInputs vp
        !campaignFundsID_CS = T.cdCampaignFundsPolicyID_CS $ vDatum vp
        !fundsDatums = OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_CS
            @CampaignFundsT.ValidatorDatum
            @CampaignFundsT.CampaignFundsDatumType
            (vCtx vp)
            refInputs
            campaignFundsID_CS
            CampaignFundsT.getCampaignFunds_DatumType 
    in case fundsDatums of
        [] -> traceError "Expected all CampaignFunds as inputRef"
        x  -> x

{-# INLINEABLE getOutput_Campaign_DatumAndValue #-}
getOutput_Campaign_DatumAndValue :: ValidationParams -> Maybe (T.CampaignDatumType, Ledger.Value)
getOutput_Campaign_DatumAndValue !vp =
    let !outputs = getOwnOutputs vp
    in case outputs of
        [output] ->
            let !maybeTxOut = OnChainHelpers.getTxOut_And_DatumType_From_TxOut_And_AC_And_Address
                    @T.ValidatorDatum
                    @T.CampaignDatumType
                    (vCtx vp)
                    output
                    (vCampaignID_AC vp)
                    (Just $ vOwnAddress vp)
                    T.getCampaign_DatumType
            in case maybeTxOut of
                Just txOut -> Just (OnChainHelpers.getDatum_In_TxOut_And_Datum txOut, LedgerApiV2.txOutValue output)
                Nothing    -> Nothing
        _ -> Nothing

{-# INLINEABLE isCampaignOpen #-}
isCampaignOpen :: ValidationParams -> Bool
isCampaignOpen !vp =
    let !datum = vDatum vp
        !info = vInfo vp
    in OnChainHelpers.isDateReached (T.cdBeginAt datum) info
       && not (OnChainHelpers.isDateReached (T.cdDeadline datum) info)

{-# INLINEABLE isCampaignFinish #-}
isCampaignFinish :: ValidationParams -> Bool
isCampaignFinish = not . isCampaignOpen

{-# INLINEABLE isCampaignStatus #-}
isCampaignStatus :: ValidationParams -> T.CapaignStatus -> Bool
isCampaignStatus !vp !status = T.cdStatus (vDatum vp) == status

{-# INLINEABLE validateValueNotChanged #-}
validateValueNotChanged :: ValidationParams -> Ledger.Value -> Bool
validateValueNotChanged !vp !outValue =
    traceIfFalse "not isCorrect_Output_Campaign_Datum_Value_NotChanged" $
    outValue `OnChainHelpers.isEqValue` vInputValue vp

--------------------------------------------------------------------------------
-- Admin Validation Functions
--------------------------------------------------------------------------------

{-# INLINEABLE isAdminTokenPresent #-}
isAdminTokenPresent :: ValidationParams -> Bool
isAdminTokenPresent !vp =
    case LedgerApiV2.txInfoOutputs $ vInfo vp of
        []           -> False
        (output : _) ->
            let !tokenAdmin_AC = LedgerValue.AssetClass (T.getAdminToken_CS $ vDatum vp, T.tokenAdmin_TN)
            in OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue output) tokenAdmin_AC

{-# INLINEABLE validateCampaignAdminAction #-}
validateCampaignAdminAction :: ValidationParams -> Bool
validateCampaignAdminAction !vp =
    ------------------
    -- Que este el token de admin presente
    -- o Que sea Campaign Admin
    ------------------
    traceIfFalse "not isSignedByAny admins nor isAdminTokenPresent"
        (OnChainHelpers.isSignedByAny ( T.getAdmins $ vDatum vp) (vInfo vp) || isAdminTokenPresent vp)

{-# INLINEABLE validateProtocolAdminAction #-}
validateProtocolAdminAction :: ValidationParams -> Maybe ProtocolT.ProtocolDatumType -> Bool
validateProtocolAdminAction !vp !mprot =
    let !admins = case mprot of
            Just protDatum -> T.getAdmins protDatum
            _                   -> traceError "Expected Protocol at inputRef"
    in traceIfFalse "not isSignedByAny admins nor isAdminTokenPresent"
        (OnChainHelpers.isSignedByAny admins (vInfo vp) || isAdminTokenPresent vp)

{-# INLINEABLE validateProtocolOrCampaignAdmin #-}
validateProtocolOrCampaignAdmin :: ValidationParams -> Bool
validateProtocolOrCampaignAdmin !vp =
    ------------------
    -- Que este el token de admin presente
    -- o Que sea Campaign Admin
    -- o Que sea Protocol Admin si hay input ref protocol
    ------------------
    let !protocolDatum = getProtocol_Datum vp
        !admins = T.getAdmins (vDatum vp) ++ maybe [] T.getAdmins protocolDatum
    in traceIfFalse "not isSignedByAny admins nor isAdminTokenPresent"
        (OnChainHelpers.isSignedByAny admins (vInfo vp) || isAdminTokenPresent vp)


--------------------------------------------------------------------------------

{-# INLINEABLE mkPolicy #-}
mkPolicy :: T.PolicyParams -> BuiltinData -> BuiltinData -> ()
mkPolicy (T.PolicyParams !protocolPolicyID_CS !campaignPolicy_TxOutRef !campaignValidator_Hash) !redRaw !ctxRaw =
    if traceIfFalse "" useThisToMakeScriptUnique
        && traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange info T.validTxTimeRange)
        && validatePolciy
        then ()
        else error ()
    where
        ------------------
        !useThisToMakeScriptUnique = protocolPolicyID_CS /= LedgerApiV2.adaSymbol
        ------------------
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.PolicyRedeemer redRaw
        !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
        !campaignPolicy_CS = LedgerContextsV2.ownCurrencySymbol ctx
        ------------------
        !ownMintingValue = OnChainHelpers.getUnsafeOwnMintingValue ctx
        ------------------
        validatePolciy :: Bool
        !validatePolciy = case redeemer of
            (T.PolicyRedeemerMintID _)            -> validateMintAndBurnIDRedeemers
            (T.PolicyRedeemerBurnID _)            -> validateMintAndBurnIDRedeemers
            (T.PolicyRedeemerMintCampaignToken _) -> validateMintAndBurnCampaignTokenRedeemers
            (T.PolicyRedeemerBurnCampaignToken _) -> validateMintAndBurnCampaignTokenRedeemers
        ------------------
        validateMintAndBurnIDRedeemers :: Bool
        validateMintAndBurnIDRedeemers =
            case redeemer of
                (T.PolicyRedeemerMintID _) ->
                    ---------------------
                    -- it runs alone
                    ---------------------
                    -- Que venga ProtocolDatum como ref
                    -- Para identificar el correcto ProtocolDatum necesita la póliza Protocol ID que está en los parámetros de esta póliza.
                    -- Que se genere salida out 0 con nuevo CampaignDatum en direcion correcta
                    -- Para identificar la direccion, tengo el validator hash en los parametros de poliza
                    -- Que el CampaignDatum sea correcto según límites y valores del ProtocolDatum
                    -- Que se mintee Campaign ID con own póliza
                    -- solo se puede ejecutar una vez por que esta parametrizado con campaignPolicy_TxOutRef
                    -- Que el CampaignDatum tenga el Campaign ID
                    ---------------------
                    -- TODO: falta validar que sea protocol admin
                    ---------------------
                    traceIfFalse "not isTxOutAnInput" (OnChainHelpers.isTxOutAnInput campaignPolicy_TxOutRef info)
                        && traceIfFalse "not isMintingID" isMintingID
                        && traceIfFalse "not isCorrect_Output_Campaign_Datum" isCorrect_Output_Campaign_Datum
                        && traceIfFalse "not isCorrect_Output_Campaign_Datum_Value" isCorrect_Output_Campaign_Datum_Value
                    where
                        ---------------------
                        -- !inputRef_TxOut_And_ProtocolDatum =
                        --     case OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_AC
                        --         @ProtocolT.ValidatorDatum
                        --         @ProtocolT.ProtocolDatumType
                        --         ctx
                        --         inputsRef_TxOuts
                        --         protocolID_AC
                        --         ProtocolT.getProtocolDatumType of
                        --         [x] -> x
                        --         _   -> traceError "Expected exactly one Protocol input ref"
                        -- ------------------
                        -- !protocolDatum_In = OnChainHelpers.getDatum_In_TxOut_And_Datum inputRef_TxOut_And_ProtocolDatum
                        ------------------
                        !outputs_txOuts =
                            [ txOut | txOut <- LedgerApiV2.txInfoOutputs info, OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress txOut)
                            ]
                        -- 0 out is the CampaignDatum
                        ------------------
                        !_ =
                            if null outputs_txOuts
                                then traceError "Expected at least one output to scripts addresses"
                                else ()
                        ------------------
                        !output_Own_TxOut_And_CampaignDatum =
                            fromMaybe
                                (traceError "Expected Campaign at output index 0")
                                ( OnChainHelpers.getTxOut_And_DatumType_From_TxOut_And_AC_And_Address
                                    @T.ValidatorDatum
                                    @T.CampaignDatumType
                                    ctx
                                    (head outputs_txOuts)
                                    campaignID_AC
                                    (Just campaignValidator_Address)
                                    T.getCampaign_DatumType
                                )
                        ------------------
                        !campaignDatum_Out = OnChainHelpers.getDatum_In_TxOut_And_Datum output_Own_TxOut_And_CampaignDatum
                        ------------------
                        !campaignFundsPolicyID_CS = T.cdCampaignFundsPolicyID_CS campaignDatum_Out
                        ------------------
                        !valueFor_Mint_CampaignID = LedgerValue.assetClassValue campaignID_AC 1
                        ---------------------
                        !minADA_For_CampaignDatum = T.cdMinADA campaignDatum_Out
                        !value_MinADA_For_CampaignDatum = LedgerAda.lovelaceValueOf minADA_For_CampaignDatum
                        !valueFor_CampaignDatum_Out_Control = valueFor_Mint_CampaignID <> value_MinADA_For_CampaignDatum
                        ---------------------
                        !admins = T.cdAdmins campaignDatum_Out
                        !tokenAdminPolicy_CS = T.cdTokenAdminPolicy_CS campaignDatum_Out
                        !mint_CampaignToken = T.cdMint_CampaignToken campaignDatum_Out
                        !campaignToken_CS = T.cdCampaignToken_CS campaignDatum_Out
                        !campaignToken_TN = T.cdCampaignToken_TN campaignDatum_Out
                        !campaignToken_PriceADA = T.cdCampaignToken_PriceADA campaignDatum_Out
                        !requestedMaxADA = T.cdRequestedMaxADA campaignDatum_Out
                        !requestedMinADA = T.cdRequestedMinADA campaignDatum_Out
                        !fundedADA = 0
                        !collectedADA = 0
                        !beginAt = T.cdBeginAt campaignDatum_Out
                        !deadline = T.cdDeadline campaignDatum_Out
                        !status = T.CsCreated
                        !milestones = T.cdMilestones campaignDatum_Out
                        !fundsCount = 0
                        !fundsIndex = 0
                        ---------------------
                        !campaignDatum_Out_Control =
                            T.mkCampaign_DatumType
                                campaignPolicy_CS
                                campaignFundsPolicyID_CS
                                admins
                                tokenAdminPolicy_CS
                                mint_CampaignToken
                                campaignToken_CS
                                campaignToken_TN
                                campaignToken_PriceADA
                                requestedMaxADA
                                requestedMinADA
                                fundedADA
                                collectedADA
                                beginAt
                                deadline
                                status
                                milestones
                                fundsCount
                                fundsIndex
                                minADA_For_CampaignDatum
                        ---------------------
                        isMintingID :: Bool
                        !isMintingID = ownMintingValue `OnChainHelpers.isEqValue` valueFor_Mint_CampaignID
                        -----------------
                        isCorrect_Output_Campaign_Datum :: Bool
                        !isCorrect_Output_Campaign_Datum =
                            let
                                -----------------
                                -- Check if campaignToken_CS equals campaignPolicy_CS when minting tokens
                                validCampaignToken_CS = not mint_CampaignToken || (campaignToken_CS == campaignPolicy_CS)
                                -- Check if campaignToken_TN is not empty
                                campaignToken_TN_BS = LedgerApiV2.unTokenName campaignToken_TN
                                validCampaignToken_TN = lengthOfByteString campaignToken_TN_BS /= 0
                                -- Check if campaignToken_PriceADA is greater than zero
                                validCampaignToken_PriceADA = campaignToken_PriceADA > 0
                                -- Check if requestedMaxADA is greater than requestedMinADA, and requestedMinADA is greater than zero
                                validRequestedMinMaxADA = requestedMinADA > 0 && requestedMaxADA > requestedMinADA
                                -- Check if requestedMaxADA and requestedMinADA are divisible by campaignToken_PriceADA
                                divisibleMax = requestedMaxADA `modulo` campaignToken_PriceADA == 0
                                divisibleMin = requestedMinADA `modulo` campaignToken_PriceADA == 0
                                validRequestedPriceDivisibility = divisibleMax && divisibleMin
                                -- Check valid milestones
                                validateMilestones =
                                    let
                                        -- Check if there is at least one milestone
                                        hasMilestones = not (null milestones)
                                        -- Check if all milestones have status MsCreated
                                        allCreatedMilestones = all (\m -> T.cmStatus m == T.MsCreated) milestones
                                        -- Check if the total percentage of all milestones sums to 100
                                        totalPercentage = sum [T.cmPerncentage m | m <- milestones]
                                        isValidPercentage = totalPercentage == 100
                                    in
                                        hasMilestones && allCreatedMilestones && isValidPercentage
                            in
                                -----------------
                                traceIfFalse "not isDateReached deadline" (OnChainHelpers.isDateNotReached deadline info)
                                    && traceIfFalse "not deadline > beginAt" (deadline > beginAt)
                                    && traceIfFalse "not validateMilestones" validateMilestones
                                    && traceIfFalse "not validCampaignToken_CS" validCampaignToken_CS
                                    && traceIfFalse "not validCampaignToken_TN" validCampaignToken_TN
                                    && traceIfFalse "not validCampaignToken_PriceADA" validCampaignToken_PriceADA
                                    && traceIfFalse "not validRequestedMinMaxADA" validRequestedMinMaxADA
                                    && traceIfFalse "not validRequestedPriceDivisibility" validRequestedPriceDivisibility
                                    && campaignDatum_Out `OnChainHelpers.isUnsafeEqDatums` campaignDatum_Out_Control

                        ------------------
                        isCorrect_Output_Campaign_Datum_Value :: Bool
                        !isCorrect_Output_Campaign_Datum_Value =
                            let
                                !valueOf_CampaignDatum_Out = OnChainHelpers.getValue_In_TxOut_And_Datum output_Own_TxOut_And_CampaignDatum
                            in
                                valueOf_CampaignDatum_Out
                                    `OnChainHelpers.isEqValue` valueFor_CampaignDatum_Out_Control
                -----------------
                (T.PolicyRedeemerBurnID _) ->
                    ------------------
                    -- it runs along with Campaign Validator (ValidatorRedeemerDelete)
                    ------------------
                    -- Que se queme Campaign ID con own póliza
                    -- No hay control del redeemer del Campaign Validator, por que se sobre entiende que de algun lado salen estos tokens
                    -- Y solo se pueden sacar consumiendo el Campaign Datum y para eso solo el validador va a permitir con el redeemer correcto
                    ---------------------
                    traceIfFalse "not isBurningID" isBurningID
                    where
                        ------------------
                        !valueFor_Burn_CampaignID = LedgerValue.assetClassValue campaignID_AC (negate 1)
                        ---------------------
                        isBurningID :: Bool
                        !isBurningID = ownMintingValue `OnChainHelpers.isEqValue` valueFor_Burn_CampaignID
                -----------------
                _ -> False
            where
                ------------------
                -- !protocolID_AC = LedgerValue.AssetClass (protocolPolicyID_CS, T.protocolID_TN)
                !campaignID_AC = LedgerValue.AssetClass (campaignPolicy_CS, T.campaignID_TN)
                ------------------
                !campaignValidator_Address = Ledger.scriptHashAddress campaignValidator_Hash
        --------------------------------------------------------------------------------2
        validateMintAndBurnCampaignTokenRedeemers :: Bool
        validateMintAndBurnCampaignTokenRedeemers  =
            case redeemer of
                (T.PolicyRedeemerMintCampaignToken _) ->
                    ------------------
                    -- it runs along with CampaignFunds Validator (ValidatorRedeemerDeposit)
                    ------------------
                    -- que este la campaign status sea CsCreated
                    -- que la campaign este configurada para mintear los tokens que se venden
                    -- que el redeemer del CampaignFunds sea ValidatorRedeemerDeposit
                    -- que se este minetando, solamente, con AC correcta
                    -- que el valor a mintear sea al determiando en el redeemer del CampaignFunds (lo reviso en el validar del CampaignFunds)
                    ------------------
                    traceIfFalse "not isCampaignCreated" isCampaignCreated
                        && traceIfFalse "not isCampaignWithMintingCampaignToken" isCampaignWithMintingCampaignToken
                        && traceIfFalse "not isCampaignFundsValidatorRedeemerDeposit" isCampaignFundsValidatorRedeemerDeposit
                        && traceIfFalse "not isMintingCampaignToken" isMintingCampaignToken
                    where
                        ------------------
                        isCampaignFundsValidatorRedeemerDeposit :: Bool
                        isCampaignFundsValidatorRedeemerDeposit = case redeemerFor_CampaignFundsDatum of
                            CampaignFundsT.ValidatorRedeemerDeposit _ -> True
                            _                                         -> False
                        ------------------
                        !amount = case redeemerFor_CampaignFundsDatum of
                            CampaignFundsT.ValidatorRedeemerDeposit (CampaignFundsT.ValidatorRedeemerDepositType amt) -> amt
                            _                                                                                         -> -1
                        -----------------
                        !valueFor_Mint_CampaignToken = LedgerValue.assetClassValue campaignToken_AC amount
                        ---------------------
                        isMintingCampaignToken :: Bool
                        !isMintingCampaignToken = amount >= 1 && ownMintingValue `OnChainHelpers.isEqValue` valueFor_Mint_CampaignToken
                ------------------
                -----------------
                (T.PolicyRedeemerBurnCampaignToken _) ->
                    ------------------
                    -- it runs along with CampaignFunds Validator (isCampaignFundsValidatorRedeemerWithdraw)
                    ------------------
                    -- que este la campaign status sea CsCreated, CsNotReached or CsFailedMilestone
                    -- que la campaign este configurada para mintear los tokens que se venden
                    -- que el redeemer del CampaignFunds sea Withdraw
                    -- que el valor a quemar sea al determiando en el redeemer del CampaignFunds (lo reviso en el validar del CampaignFunds)
                    ------------------
                    traceIfFalse "not isCampaignCreated_NotReached_Or_FailedMilestone" isCampaignCreated_NotReached_Or_FailedMilestone
                        && traceIfFalse "not isCampaignWithMintingCampaignToken" isCampaignWithMintingCampaignToken
                        && traceIfFalse "not isCampaignFundsValidatorRedeemerWithdraw" isCampaignFundsValidatorRedeemerWithdraw
                        && traceIfFalse "not isBurningCampaignToken" isBurningCampaignToken
                    where
                        ------------------
                        isCampaignCreated_NotReached_Or_FailedMilestone :: Bool
                        !isCampaignCreated_NotReached_Or_FailedMilestone =
                            isCampaignCreated || T.cdStatus campaignDatum_In == T.CsNotReached || T.cdStatus campaignDatum_In == T.CsFailedMilestone
                        ------------------
                        isCampaignFundsValidatorRedeemerWithdraw :: Bool
                        isCampaignFundsValidatorRedeemerWithdraw = case redeemerFor_CampaignFundsDatum of
                            CampaignFundsT.ValidatorRedeemerWithdraw _ -> True
                            _                                          -> False
                        ------------------
                        !amount = case redeemerFor_CampaignFundsDatum of
                            CampaignFundsT.ValidatorRedeemerWithdraw (CampaignFundsT.ValidatorRedeemerWithdrawType amt) -> amt
                            _                                                                                           -> 1
                        -----------------
                        !valueFor_Burn_CampaignToken = LedgerValue.assetClassValue campaignToken_AC (negate amount)
                        ---------------------
                        isBurningCampaignToken :: Bool
                        !isBurningCampaignToken = amount < 0 && ownMintingValue `OnChainHelpers.isEqValue` valueFor_Burn_CampaignToken
                ------------------
                _ -> False
            where
                ------------------
                !inputsRef_TxOuts =
                    [ LedgerApiV2.txInInfoResolved txInfoInput | txInfoInput <- LedgerApiV2.txInfoReferenceInputs info, OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress $ LedgerApiV2.txInInfoResolved txInfoInput)
                    ]
                ------------------
                !campaignID_AC = LedgerValue.AssetClass (campaignPolicy_CS, T.campaignID_TN)
                ------------------
                !input_TxOut_And_CampaignDatum =
                    case OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_AC
                        @T.ValidatorDatum
                        @T.CampaignDatumType
                        ctx
                        inputsRef_TxOuts
                        campaignID_AC
                        T.getCampaign_DatumType of
                        [x] -> x
                        _   -> traceError "Expected exactly one Campaign input ref"
                ------------------
                !campaignDatum_In = OnChainHelpers.getDatum_In_TxOut_And_Datum input_TxOut_And_CampaignDatum
                ------------------
                !campaignToken_TN = T.cdCampaignToken_TN campaignDatum_In
                !campaignToken_AC = LedgerValue.AssetClass (campaignPolicy_CS, campaignToken_TN)
                ------------------
                isCampaignCreated :: Bool
                !isCampaignCreated = T.cdStatus campaignDatum_In == T.CsCreated
                ------------------
                isCampaignWithMintingCampaignToken :: Bool
                !isCampaignWithMintingCampaignToken = T.cdMint_CampaignToken campaignDatum_In
                ------------------
                redeemerFor_CampaignFundsDatum :: CampaignFundsT.ValidatorRedeemer
                !redeemerFor_CampaignFundsDatum =
                    let
                        !campaignFundsPolicyID_CS = T.cdCampaignFundsPolicyID_CS campaignDatum_In
                        ------------------
                        !inputs_TxOutRefs_TxOuts = [(LedgerApiV2.txInInfoOutRef txInfoInput, LedgerApiV2.txInInfoResolved txInfoInput) | txInfoInput <- LedgerApiV2.txInfoInputs info]
                        ------------------
                        !input_TxOutRef_TxOut_And_CampaignFundsDatum =
                            case OnChainHelpers.getTxOutRefs_TxOuts_And_DatumTypes_From_TxOutRefs_TxOuts_By_CS
                                @CampaignFundsT.ValidatorDatum
                                @CampaignFundsT.CampaignFundsDatumType
                                ctx
                                inputs_TxOutRefs_TxOuts
                                campaignFundsPolicyID_CS
                                CampaignFundsT.getCampaignFunds_DatumType of
                                [x] -> x
                                _   -> traceError "Expected exactly one CampaignFunds input"
                        ------------------
                        !redeemerFor_CampaignFundsDatum' = OnChainHelpers.getRedeemerForConsumeInput ((\(txOutRef, _, _) -> txOutRef) input_TxOutRef_TxOut_And_CampaignFundsDatum) info
                    in
                        case redeemerFor_CampaignFundsDatum' of
                            Nothing -> traceError "Expected exactly one CampaignFunds input with redeemer"
                            Just redeemerFor_CampaignFundsDatum'' ->
                                case LedgerApiV2.fromBuiltinData @CampaignFundsT.ValidatorRedeemer $ LedgerApiV2.getRedeemer redeemerFor_CampaignFundsDatum'' of
                                    Just x -> x
                                    _      -> traceError "Expected exactly one CampaignFunds input with valid redeemer"

--------------------------------------------------------------------------------2

{-# INLINEABLE policy #-}
policy :: T.PolicyParams -> LedgerApiV2.MintingPolicy
policy params =
    Plutonomy.optimizeUPLC $
        Plutonomy.mintingPolicyToPlutus $
            Plutonomy.mkMintingPolicyScript $
                $$(PlutusTx.compile [||mkPolicy||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINEABLE mkWrappedPolicyID #-}
mkWrappedPolicyID :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedPolicyID protocolPolicyID_CS campaignPolicy_TxHash campaignPolicy_TxOutputIndex campaignValidator_Hash = mkPolicy params
    where
        tid = PlutusTx.unsafeFromBuiltinData campaignPolicy_TxHash :: BuiltinByteString
        txout =
            LedgerApiV2.TxOutRef
                { LedgerApiV2.txOutRefId = LedgerApiV2.TxId tid
                , LedgerApiV2.txOutRefIdx = PlutusTx.unsafeFromBuiltinData campaignPolicy_TxOutputIndex
                }
        params =
            T.PolicyParams
                { ppProtocolPolicyID_CS = PlutusTx.unsafeFromBuiltinData protocolPolicyID_CS
                , ppCampaignPolicy_TxOutRef = txout
                , ppCampaignValidator_Hash = PlutusTx.unsafeFromBuiltinData campaignValidator_Hash
                }

{-# INLINEABLE policyCode #-}
policyCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())
policyCode = Plutonomy.optimizeUPLC $$(PlutusTx.compile [||mkWrappedPolicyID||])

--------------------------------------------------------------------------------2

{-# INLINEABLE validator #-}
validator :: T.ValidatorParams -> LedgerApiV2.Validator
validator params =
    Plutonomy.optimizeUPLC $
        Plutonomy.validatorToPlutus $
            Plutonomy.mkValidatorScript $
                $$(PlutusTx.compile [||mkValidator||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINEABLE mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator protocolPolicyID_CS tokenEmergencyAdminPolicy_CS = mkValidator params
    where
        params =
            T.ValidatorParams
                { vpProtocolPolicyID_CS = PlutusTx.unsafeFromBuiltinData protocolPolicyID_CS
                , vpTokenEmergencyAdminPolicy_CS = PlutusTx.unsafeFromBuiltinData tokenEmergencyAdminPolicy_CS
                }

{-# INLINEABLE validatorCode #-}
validatorCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())
-- validatorCode = $$(PlutusTx.compile [||mkWrappedValidator||])
validatorCode = Plutonomy.optimizeUPLC $$(PlutusTx.compile [||mkWrappedValidator||])

------------------------------------------------------------------------------2

====== Campaign/Types.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE InstanceSigs          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Campaign.Types where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Data.Aeson           as DataAeson (FromJSON, ToJSON)
import qualified Data.OpenApi.Schema  as DataOpenApiSchema (ToSchema)
import qualified GHC.Generics         as GHCGenerics (Generic)
import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import qualified PlutusTx
import           PlutusTx.Prelude
import qualified Prelude              as P
import qualified Schema

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Constants            as T
import qualified Helpers.Types        as T
import qualified Types                as T
import qualified Helpers.OnChain as OnChainHelpers
import qualified Protocol.Types as ProtocolT

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

-- Any change in the logic, datum or redeemer must change the version of the fundVersion
campaignVersion :: Integer
campaignVersion = 1

ownVersion :: Integer
ownVersion = T.mkVersionWithDependency [ProtocolT.protocolVersion] campaignVersion

--------------------------------------------------------------------------------2
-- Params
--------------------------------------------------------------------------------2

data PolicyParams
    = PolicyParams
          { ppProtocolPolicyID_CS     :: LedgerApiV2.CurrencySymbol
          , ppCampaignPolicy_TxOutRef :: LedgerApiV2.TxOutRef
          , ppCampaignValidator_Hash  :: LedgerApiV2.ValidatorHash
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

instance Eq PolicyParams where
    {-# INLINABLE (==) #-}
    pp1 == pp2 =
        ppProtocolPolicyID_CS pp1 == ppProtocolPolicyID_CS pp2
            && ppCampaignPolicy_TxOutRef pp1 == ppCampaignPolicy_TxOutRef pp2
            && ppCampaignValidator_Hash pp1 == ppCampaignValidator_Hash pp2

PlutusTx.makeLift ''PolicyParams

PlutusTx.makeIsDataIndexed ''PolicyParams [('PolicyParams, 0)]

data ValidatorParams
    = ValidatorParams
          { vpProtocolPolicyID_CS          :: LedgerApiV2.CurrencySymbol
          , vpTokenEmergencyAdminPolicy_CS :: LedgerApiV2.CurrencySymbol
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

-- instance Schema.ToSchema ValidatorParams where
--     toSchema = Schema.FormSchemaUnit

instance Eq ValidatorParams where
    {-# INLINABLE (==) #-}
    pp1 == pp2 =
        vpProtocolPolicyID_CS pp1 == vpProtocolPolicyID_CS pp2
        && vpTokenEmergencyAdminPolicy_CS pp1 == vpTokenEmergencyAdminPolicy_CS pp2

PlutusTx.makeLift ''ValidatorParams

PlutusTx.makeIsDataIndexed ''ValidatorParams [('ValidatorParams, 0)]

--------------------------------------------------------------------------------2
-- Datums
--------------------------------------------------------------------------------2

data CapaignStatus = CsCreated | CsInitialized | CsReached | CsNotReached | CsFailedMilestone deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq CapaignStatus where
    {-# INLINABLE (==) #-}
    (==) :: CapaignStatus -> CapaignStatus -> Bool
    CsCreated == CsCreated                 = True
    CsInitialized == CsInitialized         = True
    CsReached == CsReached                 = True
    CsNotReached == CsNotReached           = True
    CsFailedMilestone == CsFailedMilestone = True
    _ == _                                 = False

PlutusTx.makeIsDataIndexed ''CapaignStatus [('CsCreated, 1), ('CsInitialized, 2), ('CsReached, 3), ('CsNotReached, 4), ('CsFailedMilestone, 5)]

data MilestoneStatus = MsCreated | MsSuccess | MsFailed deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq MilestoneStatus where
    {-# INLINABLE (==) #-}
    (==) :: MilestoneStatus -> MilestoneStatus -> Bool
    MsCreated == MsCreated = True
    MsSuccess == MsSuccess = True
    MsFailed == MsFailed   = True
    _ == _                 = False

PlutusTx.makeIsDataIndexed ''MilestoneStatus [('MsCreated, 1), ('MsSuccess, 2), ('MsFailed, 3)]

data CampaignMilestones
    = CampaignMilestones
          { cmPerncentage           :: Integer
          , cmStatus                :: MilestoneStatus
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq CampaignMilestones where
  {-# INLINABLE (==) #-}
  (==) :: CampaignMilestones -> CampaignMilestones -> Bool
  cm1 == cm2 =
    cmPerncentage cm1 == cmPerncentage cm2
        && cmStatus cm1 == cmStatus cm2

PlutusTx.makeIsDataIndexed ''CampaignMilestones [('CampaignMilestones, 0)]

data CampaignDatumType
    = CampaignDatumType
          { cdCampaignVersion          :: Integer
          , cdCampaignPolicy_CS        :: T.CS
          , cdCampaignFundsPolicyID_CS :: T.CS
          , cdAdmins                   :: [T.WalletPaymentPKH]
          , cdTokenAdminPolicy_CS      :: LedgerApiV2.CurrencySymbol
          , cdMint_CampaignToken          :: Bool
          , cdCampaignToken_CS            :: T.CS
          , cdCampaignToken_TN            :: T.TN
          , cdCampaignToken_PriceADA      :: Integer
          , cdRequestedMaxADA          :: Integer
          , cdRequestedMinADA          :: Integer
          , cdFundedADA                :: Integer
          , cdCollectedADA             :: Integer
          , cdBeginAt                  :: LedgerApiV2.POSIXTime
          , cdDeadline                 :: LedgerApiV2.POSIXTime
          , cdStatus                   :: CapaignStatus
          , cdMilestones               :: [CampaignMilestones]
          , cdFundsCount               :: Integer
          , cdFundsIndex               :: Integer
          , cdMinADA                   :: Integer
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq CampaignDatumType where
  {-# INLINABLE (==) #-}
  ps1 == ps2 =
    cdCampaignVersion ps1 == cdCampaignVersion ps2
        && cdCampaignPolicy_CS ps1 == cdCampaignPolicy_CS ps2
        && cdCampaignFundsPolicyID_CS ps1 == cdCampaignFundsPolicyID_CS ps2
        && cdAdmins ps1 == cdAdmins ps2
        && cdTokenAdminPolicy_CS ps1 == cdTokenAdminPolicy_CS ps2
        && cdMint_CampaignToken ps1 == cdMint_CampaignToken ps2
        && cdCampaignToken_CS ps1 == cdCampaignToken_CS ps2
        && cdCampaignToken_TN ps1 == cdCampaignToken_TN ps2
        && cdCampaignToken_PriceADA ps1 == cdCampaignToken_PriceADA ps2
        && cdRequestedMaxADA ps1 == cdRequestedMaxADA ps2
        && cdRequestedMinADA ps1 == cdRequestedMinADA ps2
        && cdFundedADA ps1 == cdFundedADA ps2
        && cdCollectedADA ps1 == cdCollectedADA ps2
        && cdBeginAt ps1 == cdBeginAt ps2
        && cdDeadline ps1 == cdDeadline ps2
        && cdStatus ps1 == cdStatus ps2
        && cdMilestones ps1 == cdMilestones ps2
        && cdFundsCount ps1 == cdFundsCount ps2
        && cdFundsIndex ps1 == cdFundsIndex ps2
        && cdMinADA ps1 == cdMinADA ps2

instance T.HasAdmins CampaignDatumType where
    {-# INLINABLE getAdmins #-}
    getAdmins = cdAdmins

instance T.HasAdminToken CampaignDatumType where
    {-# INLINABLE getAdminToken_CS #-}
    getAdminToken_CS = cdTokenAdminPolicy_CS

PlutusTx.makeIsDataIndexed ''CampaignDatumType [('CampaignDatumType, 0)]

--------------------------------------------------------------------------------2

newtype ValidatorDatum
    = CampaignDatum CampaignDatumType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq ValidatorDatum where
    {-# INLINABLE (==) #-}
    CampaignDatum mps1 == CampaignDatum mps2 = mps1 == mps2

PlutusTx.makeIsDataIndexed ''ValidatorDatum [('CampaignDatum, 0)]

{-# INLINABLE getCampaign_DatumType #-}
getCampaign_DatumType :: ValidatorDatum -> CampaignDatumType
getCampaign_DatumType (CampaignDatum sdType) = sdType

{-# INLINEABLE getCampaign_DatumType_From_UTxO #-}
getCampaign_DatumType_From_UTxO :: LedgerApiV2.TxOut -> CampaignDatumType
getCampaign_DatumType_From_UTxO utxo = case OnChainHelpers.getInlineDatum_From_TxOut @ValidatorDatum utxo of
                    Nothing     -> P.error "No Campaign Datum found"
                    Just datum' -> getCampaign_DatumType datum'

instance T.ShowDatum ValidatorDatum where
  showCborAsDatumType cbor =
    case LedgerApiV2.fromBuiltinData @ValidatorDatum cbor of
        Nothing -> Nothing
        Just d  -> Just $ P.show d

--------------------------------------------------------------------------------2

{-# INLINABLE mkCampaign_DatumType #-}
mkCampaign_DatumType ::
        T.CS
    -> T.CS
    -> [T.WalletPaymentPKH]
    -> LedgerApiV2.CurrencySymbol
    -> Bool
    -> T.CS
    -> T.TN
    -> Integer
    -> Integer
    -> Integer
    -> Integer
    -> Integer
    -> LedgerApiV2.POSIXTime
    -> LedgerApiV2.POSIXTime
    -> CapaignStatus
    -> [CampaignMilestones]
    -> Integer
    -> Integer
    -> Integer
    -> CampaignDatumType
mkCampaign_DatumType
    campaignPolicy_CS
    campaignFundsPolicyID_CS
    admins
    tokenAdminPolicy_CS
    mint_CampaignToken
    campaignToken_CS
    campaignToken_TN
    campaignToken_PriceADA
    requestedMaxADA
    requestedMinADA
    fundedADA
    collectedADA
    beginAt
    deadline
    status
    milestones
    fundsCount
    fundsIndex
    minADA
    =
    let !adminsOrdered = sort admins
    in  CampaignDatumType
            {
            cdCampaignVersion = ownVersion
            , cdCampaignPolicy_CS          =  campaignPolicy_CS
            , cdCampaignFundsPolicyID_CS   =  campaignFundsPolicyID_CS
            , cdAdmins                     =  adminsOrdered
            , cdTokenAdminPolicy_CS        =  tokenAdminPolicy_CS
            , cdMint_CampaignToken            =  mint_CampaignToken
            , cdCampaignToken_CS              =  campaignToken_CS
            , cdCampaignToken_TN              =  campaignToken_TN
            , cdCampaignToken_PriceADA        =  campaignToken_PriceADA
            , cdRequestedMaxADA            =  requestedMaxADA
            , cdRequestedMinADA            =  requestedMinADA
            , cdFundedADA                   =  fundedADA
            , cdCollectedADA                =  collectedADA
            , cdBeginAt                    =  beginAt
            , cdDeadline                   =  deadline
            , cdStatus                     =  status
            , cdMilestones                 =  milestones
            , cdFundsCount                 =  fundsCount
            , cdFundsIndex                 =  fundsIndex
            , cdMinADA                     =  minADA
            }

{-# INLINABLE mkCampaign_Datum #-}
mkCampaign_Datum ::
        T.CS
    -> T.CS
    -> [T.WalletPaymentPKH]
    -> LedgerApiV2.CurrencySymbol
    -> Bool
    -> T.CS
    -> T.TN
    -> Integer
    -> Integer
    -> Integer
    -> Integer
    -> Integer
    -> LedgerApiV2.POSIXTime
    -> LedgerApiV2.POSIXTime
    -> CapaignStatus
    -> [CampaignMilestones]
    -> Integer
    -> Integer
    -> Integer
    -> ValidatorDatum
mkCampaign_Datum
    campaignPolicy_CS
    campaignFundsPolicyID_CS
    admins
    tokenAdminPolicy_CS
    mint_CampaignToken
    campaignToken_CS
    campaignToken_TN
    campaignToken_PriceADA
    requestedMaxADA
    requestedMinADA
    fundedADA
    collectedADA
    beginAt
    deadline
    status
    milestones
    fundsCount
    fundsIndex
    minADA =
  CampaignDatum
    $ mkCampaign_DatumType
        campaignPolicy_CS
        campaignFundsPolicyID_CS
        admins
        tokenAdminPolicy_CS
        mint_CampaignToken
        campaignToken_CS
        campaignToken_TN
        campaignToken_PriceADA
        requestedMaxADA
        requestedMinADA
        fundedADA
        collectedADA
        beginAt
        deadline
        status
        milestones
        fundsCount
        fundsIndex
        minADA

mkDatum :: CampaignDatumType -> LedgerApiV2.Datum
mkDatum = LedgerApiV2.Datum . LedgerApiV2.toBuiltinData . CampaignDatum

--------------------------------------------------------------------------------2
-- PolicyRedeemer
--------------------------------------------------------------------------------2

data PolicyRedeemerMintIDType = PolicyRedeemerMintIDType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerMintIDType where
    {-# INLINABLE (==) #-}
    (==) :: PolicyRedeemerMintIDType -> PolicyRedeemerMintIDType -> Bool
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemerMintIDType
    [('PolicyRedeemerMintIDType, 0)]

data PolicyRedeemerBurnIDType = PolicyRedeemerBurnIDType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerBurnIDType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemerBurnIDType
    [('PolicyRedeemerBurnIDType, 0)]

data PolicyRedeemerMintCampaignTokenType = PolicyRedeemerMintCampaignTokenType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerMintCampaignTokenType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemerMintCampaignTokenType
    [('PolicyRedeemerMintCampaignTokenType, 0)]

data PolicyRedeemerBurnCampaignTokenType = PolicyRedeemerBurnCampaignTokenType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerBurnCampaignTokenType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemerBurnCampaignTokenType
    [('PolicyRedeemerBurnCampaignTokenType, 0)]

data PolicyRedeemer
    = PolicyRedeemerMintID PolicyRedeemerMintIDType
    | PolicyRedeemerBurnID PolicyRedeemerBurnIDType
    | PolicyRedeemerMintCampaignToken PolicyRedeemerMintCampaignTokenType
    | PolicyRedeemerBurnCampaignToken PolicyRedeemerBurnCampaignTokenType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemer where
    {-# INLINABLE (==) #-}
    PolicyRedeemerMintID rmtx1 == PolicyRedeemerMintID rmtx2 = rmtx1 == rmtx2
    PolicyRedeemerBurnID rmtx1 == PolicyRedeemerBurnID rmtx2 = rmtx1 == rmtx2
    PolicyRedeemerMintCampaignToken rmtx1 == PolicyRedeemerMintCampaignToken rmtx2 = rmtx1 == rmtx2
    PolicyRedeemerBurnCampaignToken rmtx1 == PolicyRedeemerBurnCampaignToken rmtx2 = rmtx1 == rmtx2
    _ == _                                                   = False

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemer
    [ ('PolicyRedeemerMintID, 0)
    , ('PolicyRedeemerBurnID, 1)
    , ('PolicyRedeemerMintCampaignToken, 2)
    , ('PolicyRedeemerBurnCampaignToken, 3)
    ]


--------------------------------------------------------------------------------2

getPolicyRedeemerName :: Maybe PolicyRedeemer -> Maybe P.String
getPolicyRedeemerName (Just (PolicyRedeemerMintID PolicyRedeemerMintIDType)) = Just "MintID"
getPolicyRedeemerName (Just (PolicyRedeemerBurnID PolicyRedeemerBurnIDType)) = Just "BurnID"
getPolicyRedeemerName (Just (PolicyRedeemerMintCampaignToken PolicyRedeemerMintCampaignTokenType)) = Just "MintCampaignToken"
getPolicyRedeemerName (Just (PolicyRedeemerBurnCampaignToken PolicyRedeemerBurnCampaignTokenType)) = Just "BurnCampaignToken"
getPolicyRedeemerName _                                                      = Nothing

--------------------------------------------------------------------------------22
-- ValidatorRedeemer
--------------------------------------------------------------------------------2
data ValidatorRedeemerDatumUpdateType = ValidatorRedeemerDatumUpdateType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerDatumUpdateType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerDatumUpdateType
    [('ValidatorRedeemerDatumUpdateType, 0)]

--------------------------------------------------------------------------------2
data ValidatorRedeemerUpdateMinADAType = ValidatorRedeemerUpdateMinADAType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerUpdateMinADAType where
    {-# INLINABLE (==) #-}
    r1 == r2 =  r1 ==  r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerUpdateMinADAType
    [('ValidatorRedeemerUpdateMinADAType, 0)]

--------------------------------------------------------------------------------2
data ValidatorRedeemerFundsAddType = ValidatorRedeemerFundsAddType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerFundsAddType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerFundsAddType
    [('ValidatorRedeemerFundsAddType, 0)]

--------------------------------------------------------------------------------2
newtype ValidatorRedeemerFundsMergeType
    = ValidatorRedeemerFundsMergeType { rfmQuantity :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerFundsMergeType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerFundsMergeType
    [('ValidatorRedeemerFundsMergeType, 0)]

--------------------------------------------------------------------------------2
newtype ValidatorRedeemerFundsDeleteType
    = ValidatorRedeemerFundsDeleteType { rfdQuantity :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerFundsDeleteType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerFundsDeleteType
    [('ValidatorRedeemerFundsDeleteType, 0)]


--------------------------------------------------------------------------------2

newtype ValidatorRedeemerFundsCollectType
    = ValidatorRedeemerFundsCollectType
          { rfcAmount :: Integer
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerFundsCollectType where
    {-# INLINABLE (==) #-}
    r1 == r2 =
        rfcAmount r1 == rfcAmount r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerFundsCollectType
    [('ValidatorRedeemerFundsCollectType, 0)]


--------------------------------------------------------------------------------2
data ValidatorRedeemerInitializeCampaignType = ValidatorRedeemerInitializeCampaignType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerInitializeCampaignType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerInitializeCampaignType
    [('ValidatorRedeemerInitializeCampaignType, 0)]

--------------------------------------------------------------------------------2

data ValidatorRedeemerReachedCampaignType = ValidatorRedeemerReachedCampaignType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerReachedCampaignType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerReachedCampaignType
    [('ValidatorRedeemerReachedCampaignType, 0)]

--------------------------------------------------------------------------------2

data ValidatorRedeemerNotReachedCampaignType = ValidatorRedeemerNotReachedCampaignType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerNotReachedCampaignType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerNotReachedCampaignType
    [('ValidatorRedeemerNotReachedCampaignType, 0)]

--------------------------------------------------------------------------------222

newtype ValidatorRedeemerMilestoneAprobeType
    = ValidatorRedeemerMilestoneAprobeType { rmaMilestoneIndex :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerMilestoneAprobeType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerMilestoneAprobeType
    [('ValidatorRedeemerMilestoneAprobeType, 0)]
--------------------------------------------------------------------------------2
newtype ValidatorRedeemerMilestoneReprobeType
    = ValidatorRedeemerMilestoneReprobeType { rmrMilestoneIndex :: Integer }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerMilestoneReprobeType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerMilestoneReprobeType
    [('ValidatorRedeemerMilestoneReprobeType, 0)]

--------------------------------------------------------------------------------2

data ValidatorRedeemerEmergencyType = ValidatorRedeemerEmergencyType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerEmergencyType where
    {-# INLINABLE (==) #-}
    r1 == r2 =  r1 ==  r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerEmergencyType
    [('ValidatorRedeemerEmergencyType, 0)]

--------------------------------------------------------------------------------2
data ValidatorRedeemerDeleteType = ValidatorRedeemerDeleteType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerDeleteType where
    {-# INLINABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerDeleteType
    [('ValidatorRedeemerDeleteType, 0)]

--------------------------------------------------------------------------------2
data ValidatorRedeemer
    = ValidatorRedeemerDatumUpdate ValidatorRedeemerDatumUpdateType
    | ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType
    | ValidatorRedeemerFundsAdd ValidatorRedeemerFundsAddType
    | ValidatorRedeemerFundsMerge ValidatorRedeemerFundsMergeType
    | ValidatorRedeemerFundsDelete ValidatorRedeemerFundsDeleteType
    | ValidatorRedeemerFundsCollect ValidatorRedeemerFundsCollectType
    | ValidatorRedeemerInitializeCampaign ValidatorRedeemerInitializeCampaignType
    | ValidatorRedeemerReachedCampaign ValidatorRedeemerReachedCampaignType
    | ValidatorRedeemerNotReachedCampaign ValidatorRedeemerNotReachedCampaignType
    | ValidatorRedeemerMilestoneAprobe ValidatorRedeemerMilestoneAprobeType
    | ValidatorRedeemerMilestoneReprobe ValidatorRedeemerMilestoneReprobeType
    | ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType
    | ValidatorRedeemerDelete ValidatorRedeemerDeleteType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemer where
    {-# INLINABLE (==) #-}
    (==) :: ValidatorRedeemer -> ValidatorRedeemer -> Bool
    ValidatorRedeemerDatumUpdate rmf1 == ValidatorRedeemerDatumUpdate rmf2 =
        rmf1 == rmf2
    ValidatorRedeemerUpdateMinADA rmcp1 == ValidatorRedeemerUpdateMinADA rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerFundsAdd rmcp1 == ValidatorRedeemerFundsAdd rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerFundsMerge rmcp1 == ValidatorRedeemerFundsMerge rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerFundsDelete rmcp1 == ValidatorRedeemerFundsDelete rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerInitializeCampaign rmcp1 == ValidatorRedeemerInitializeCampaign rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerMilestoneAprobe rmcp1 == ValidatorRedeemerMilestoneAprobe rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerMilestoneReprobe rmcp1 == ValidatorRedeemerMilestoneReprobe rmcp2 =
        rmcp1 == rmcp2
    ValidatorRedeemerEmergency rmcp1 == ValidatorRedeemerEmergency rmcp2                 = rmcp1 == rmcp2
    ValidatorRedeemerDelete rmcp1 == ValidatorRedeemerDelete rmcp2 =
        rmcp1 == rmcp2
    _ == _ = False

PlutusTx.makeIsDataIndexed
  ''ValidatorRedeemer
    [ ('ValidatorRedeemerDatumUpdate, 0)
    , ('ValidatorRedeemerUpdateMinADA, 1)
    , ('ValidatorRedeemerFundsAdd, 2)
    , ('ValidatorRedeemerFundsMerge, 4)
    , ('ValidatorRedeemerFundsDelete, 3)
    , ('ValidatorRedeemerFundsCollect, 12)
    , ('ValidatorRedeemerInitializeCampaign, 9)
    , ('ValidatorRedeemerReachedCampaign, 10)
    , ('ValidatorRedeemerNotReachedCampaign, 11)
    , ('ValidatorRedeemerMilestoneAprobe, 5)
    , ('ValidatorRedeemerMilestoneReprobe, 6)
    , ('ValidatorRedeemerEmergency, 7)
    , ('ValidatorRedeemerDelete, 8)
    ]
--------------------------------------------------------------------------------2

getValidatorRedeemerName :: Maybe ValidatorRedeemer -> Maybe P.String
getValidatorRedeemerName (Just (ValidatorRedeemerDatumUpdate ValidatorRedeemerDatumUpdateType))             = Just "DatumUpdate"
getValidatorRedeemerName (Just (ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType))           = Just "UpdateMinADA"
getValidatorRedeemerName (Just (ValidatorRedeemerFundsAdd ValidatorRedeemerFundsAddType))                   = Just "FundsAdd"
getValidatorRedeemerName (Just (ValidatorRedeemerFundsMerge (ValidatorRedeemerFundsMergeType _)))           = Just "FundsMerge"
getValidatorRedeemerName (Just (ValidatorRedeemerFundsDelete (ValidatorRedeemerFundsDeleteType _)))         = Just "FundsDelete"
getValidatorRedeemerName (Just (ValidatorRedeemerFundsCollect (ValidatorRedeemerFundsCollectType _)))     = Just "FundsCollect"
getValidatorRedeemerName (Just (ValidatorRedeemerInitializeCampaign ValidatorRedeemerInitializeCampaignType)) = Just "InitializeCampaign"
getValidatorRedeemerName (Just (ValidatorRedeemerReachedCampaign ValidatorRedeemerReachedCampaignType))     = Just "ReachedCampaign"
getValidatorRedeemerName (Just (ValidatorRedeemerNotReachedCampaign ValidatorRedeemerNotReachedCampaignType)) = Just "NotReachedCampaign"
getValidatorRedeemerName (Just (ValidatorRedeemerMilestoneAprobe (ValidatorRedeemerMilestoneAprobeType _))) = Just "MilestoneAprobe"
getValidatorRedeemerName (Just (ValidatorRedeemerMilestoneReprobe (ValidatorRedeemerMilestoneReprobeType _))) = Just "MilestoneReprobe"
getValidatorRedeemerName (Just (ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType))                   = Just "Emergency"
getValidatorRedeemerName (Just (ValidatorRedeemerDelete ValidatorRedeemerDeleteType))                         = Just "Delete"
getValidatorRedeemerName _                                                                                  = Nothing

--------------------------------------------------------------------------------22

mkMintCampaignTokenRedeemer :: LedgerApiV2.Redeemer
mkMintCampaignTokenRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerMintCampaignToken PolicyRedeemerMintCampaignTokenType

mkBurnCampaignTokenRedeemer :: LedgerApiV2.Redeemer
mkBurnCampaignTokenRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerBurnCampaignToken PolicyRedeemerBurnCampaignTokenType

mkMintIDRedeemer :: LedgerApiV2.Redeemer
mkMintIDRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerMintID PolicyRedeemerMintIDType

mkBurnIDRedeemer :: LedgerApiV2.Redeemer
mkBurnIDRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerBurnID PolicyRedeemerBurnIDType

--------------------------------------------------------------------------------2

mkDatumUpdateRedeemer :: LedgerApiV2.Redeemer
mkDatumUpdateRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerDatumUpdate ValidatorRedeemerDatumUpdateType

mkUpdateMinADARedeemer :: LedgerApiV2.Redeemer
mkUpdateMinADARedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType

mkCampaignFundsAddRedeemer :: LedgerApiV2.Redeemer
mkCampaignFundsAddRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerFundsAdd ValidatorRedeemerFundsAddType

mkCampaignFundsMergeRedeemer :: Integer -> LedgerApiV2.Redeemer
mkCampaignFundsMergeRedeemer quantity =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerFundsMerge $ ValidatorRedeemerFundsMergeType quantity

mkCampaignFundsDeleteRedeemer :: Integer ->  LedgerApiV2.Redeemer
mkCampaignFundsDeleteRedeemer quantity =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerFundsDelete $ ValidatorRedeemerFundsDeleteType quantity

mkCampaignFundsCollectRedeemer :: Integer -> LedgerApiV2.Redeemer
mkCampaignFundsCollectRedeemer amount' =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerFundsCollect $ ValidatorRedeemerFundsCollectType amount'

mkInitializeCampaignRedeemer :: LedgerApiV2.Redeemer
mkInitializeCampaignRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerInitializeCampaign ValidatorRedeemerInitializeCampaignType

mkReachedCampaignRedeemer :: LedgerApiV2.Redeemer
mkReachedCampaignRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerReachedCampaign ValidatorRedeemerReachedCampaignType

mkNotReachedCampaignRedeemer :: LedgerApiV2.Redeemer
mkNotReachedCampaignRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerNotReachedCampaign ValidatorRedeemerNotReachedCampaignType

mkMilestoneAprobeRedeemer :: Integer -> LedgerApiV2.Redeemer
mkMilestoneAprobeRedeemer milestoneIndex =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerMilestoneAprobe $ ValidatorRedeemerMilestoneAprobeType milestoneIndex

mkMilestoneReprobeRedeemer :: Integer -> LedgerApiV2.Redeemer
mkMilestoneReprobeRedeemer milestoneIndex =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerMilestoneReprobe $ ValidatorRedeemerMilestoneReprobeType milestoneIndex

mkEmergencyRedeemer :: LedgerApiV2.Redeemer
mkEmergencyRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType

mkDeleteRedeemer :: LedgerApiV2.Redeemer
mkDeleteRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerDelete ValidatorRedeemerDeleteType

--------------------------------------------------------------------------------2

====== Constants.hs ======

{-# LANGUAGE DataKinds    #-}
{-# LANGUAGE TypeFamilies #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Constants where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import           PlutusTx.Prelude

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Helpers.Types        as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

validTxTimeRange :: LedgerApiV2.POSIXTime
validTxTimeRange = 900_000 -- 15 * 60 * 1000 = 15 minutos

--------------------------------------------------------------------------------2

protocolID_TN :: T.TN
protocolID_TN = LedgerApiV2.TokenName "ProtocolID"

tokenEmergencyAdmin_TN :: T.TN
tokenEmergencyAdmin_TN = LedgerApiV2.TokenName "EmergencyAdmin"

tokenAdmin_TN :: T.TN
tokenAdmin_TN = LedgerApiV2.TokenName "Admin"

campaignID_TN :: T.TN
campaignID_TN = LedgerApiV2.TokenName "CampaignID"

campaignFundsID_TN_basename :: BuiltinByteString
campaignFundsID_TN_basename = "CampaignFundsID"

--------------------------------------------------------------------------------2

-- protocolVersion :: Integer
-- protocolVersion = 1

-- campaignVersion :: Integer
-- campaignVersion = 1

--------------------------------------------------------------------------------2

-- | Helper function to create a version number with a dependency
mkVersionWithDependency :: [Integer] -> Integer -> Integer
mkVersionWithDependency xs ownVersion
  = foldr (\x acc -> acc * 100 + x) ownVersion xs

--------------------------------------------------------------------------------2

====== Deploy.hs ======

{-# LANGUAGE AllowAmbiguousTypes   #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE DerivingStrategies    #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes            #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
{- HLINT ignore "Reduce duplication" -}
--------------------------------------------------------------------------------2

module Deploy where

--------------------------------------------------------------------------------2
-- External Imports
--------------------------------------------------------------------------------2
import qualified Control.Monad.IO.Class  as MonadIOClass (MonadIO (..))
import qualified Data.Aeson              as DataAeson (FromJSON, ToJSON)
import qualified Data.OpenApi.Schema     as DataOpenApiSchema (ToSchema)
import qualified Data.Time               as DataTime (defaultTimeLocale, formatTime, getCurrentTime)
import qualified GHC.Generics            as GHCGenerics (Generic)
import qualified PlutusTx
import           PlutusTx.Prelude        hiding (unless)
import qualified Prelude                 as P
import qualified Schema
import qualified System.Directory        as SystemDirectory
import qualified System.FilePath.Posix   as SystemFilePathPosix
-- import qualified Plutonomy
-- import qualified Plutus.V2.Ledger.Api    as LedgerApiV2
-- import qualified PlutusTx.Builtins.Class as TxBuiltinsClass

--------------------------------------------------------------------------------2
-- Internal Imports
--------------------------------------------------------------------------------2

import qualified Campaign.Funds.OnChain  as CampaignFundsOnChain
import qualified Campaign.Funds.Types    as CampaignFundsT
import qualified Campaign.OnChain        as CampaignOnChain
import qualified Campaign.Types          as CampaignT
import qualified Constants               as T
import qualified Helpers.CLI             as CLIHelpers
import qualified Helpers.Deploy          as DeployHelpers
import qualified Helpers.OffChain        as OffChainHelpers
import qualified Protocol.OnChain        as ProtocolOnChain
import qualified Protocol.Types          as ProtocolT
import qualified Script.OnChain          as ScriptOnChain
import qualified Script.Types            as ScriptT

--------------------------------------------------------------------------------2
-- Types
--------------------------------------------------------------------------------2

-- data ProtocolDeployParams
--     = ProtocolDeployParams
--           { pdpProtocolVersion                       :: Integer
--           , pdpTokenEmergencyAdmin_CS                :: LedgerApiV2.CurrencySymbol
--           , pdpProtocolPolicyID_Params               :: ProtocolT.PolicyParams
--           , pdpProtocolPolicyID_CborHex              :: P.String
--           , pdpProtocolPolicyID_CS                   :: LedgerApiV2.CurrencySymbol
--           , pdpProtocolValidator_Params              :: ProtocolT.ValidatorParams
--           , pdpProtocolValidator_Hash                :: LedgerApiV2.ValidatorHash
--           , pdpProtocolValidator_CborHex             :: P.String
--           , pdpProtocolValidator_AddressTestnet      :: P.String
--           , pdpProtocolValidator_AddressMainnet      :: P.String
--           , pdpScriptPolicyID_Params                 :: ScriptT.PolicyParams
--           , pdpScriptPolicyID_CborHex                :: P.String
--           , pdpScriptPolicyID_CS                     :: LedgerApiV2.CurrencySymbol
--           , pdpScriptValidator_Params                :: ScriptT.ValidatorParams
--           , pdpScriptValidator_Hash                  :: LedgerApiV2.ValidatorHash
--           , pdpScriptValidator_CborHex               :: P.String
--           , pdpScriptValidator_AddressTestnet        :: P.String
--           , pdpScriptValidator_AddressMainnet        :: P.String
--           , pdpCampaignValidator_Params              :: CampaignT.ValidatorParams
--           , pdpCampaignValidator_Hash                :: LedgerApiV2.ValidatorHash
--           , pdpCampaignValidator_CborHex             :: P.String
--           , pdpCampaignValidator_AddressTestnet      :: P.String
--           , pdpCampaignValidator_AddressMainnet      :: P.String
--           , pdpCampaignFundsValidator_Params         :: CampaignFundsT.ValidatorParams
--           , pdpCampaignFundsValidator_Hash           :: LedgerApiV2.ValidatorHash
--           , pdpCampaignFundsValidator_CborHex        :: P.String
--           , pdpCampaignFundsValidator_AddressTestnet :: P.String
--           , pdpCampaignFundsValidator_AddressMainnet :: P.String
--           }
--     deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

-- data CampaignFactoryDeployParams
--     = CampaignFactoryDeployParams
--           { ffdpCampaignVersion                   :: Integer
--           , ffdpCampaignPolicy_Pre_CborHex        :: P.String
--           , ffdpCampaignFundsPolicyID_Pre_CborHex :: P.String
--           }
--     deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)


data ProtocolAndCampaignFactoryDeployParams
    = ProtocolAndCampaignFactoryDeployParams
          { fdpProtocolVersion                    :: Integer
          , fdpCampaignVersion                    :: Integer
          , fdpScriptVersion                      :: Integer
          , fdpProtocolPolicyID_Pre_CborHex       :: P.String
          , fdpProtocolValidator_Pre_CborHex      :: P.String
          , fdpScriptPolicyID_Pre_CborHex         :: P.String
          , fdpScriptValidator_Pre_CborHex        :: P.String
          , fdpCampaignPolicy_Pre_CborHex         :: P.String
          , fdpCampaignValidator_Pre_CborHex      :: P.String
          , fdpCampaignFundsPolicyID_Pre_CborHex  :: P.String
          , fdpCampaignFundsValidator_Pre_CborHex :: P.String
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

-- --------------------------------------------------------------------------------2
-- -- Module
-- --------------------------------------------------------------------------------2

-- -- Para obtener deploy file de un protocolo especifico con una fabrica de Campaign incluida
-- deploy_Protocol_And_CampaignFactory_With_StringParams :: P.String -> P.String -> P.IO ()
-- deploy_Protocol_And_CampaignFactory_With_StringParams protocolPolicyID_TxOutRefStr tokenEmergencyAdminPolicy_CS_Str = do
--     ------------------------------
--     let path = "export/protocol-v" ++ P.show T.protocolVersion
--     ------------------------------
--     -- Get the current time
--     currentTime <- MonadIOClass.liftIO DataTime.getCurrentTime
--     -- Format the time. "%Y-%m-%d-%H-%M" corresponds to "yyyy-mm-dd-hh-mm"
--     let defaultName = DataTime.formatTime DataTime.defaultTimeLocale "%Y-%m-%d-%H-%M" currentTime
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn $ "Protocol Name (default=" ++ defaultName ++ "):"
--     !protocolName <- MonadIOClass.liftIO $ CLIHelpers.getStrWithDefault defaultName
--     ------------------------------
--     let
--         !protocolPolicyID_TxOutRef = OffChainHelpers.unsafeReadTxOutRef protocolPolicyID_TxOutRefStr
--         !tokenEmergencyAdminPolicy_CS = LedgerApiV2.CurrencySymbol $ TxBuiltinsClass.toBuiltin  $ OffChainHelpers.stringFromHexString tokenEmergencyAdminPolicy_CS_Str
--     ------------------------------
--     deploy_Protocol path protocolName protocolPolicyID_TxOutRef tokenEmergencyAdminPolicy_CS
--     -- deploy_CampaignFactory (path SystemFilePathPosix.</> protocolName) "campaign-factory"

-- -- Para obtener deploy files de un protocolo especifico
-- deploy_Protocol :: P.FilePath -> P.String -> LedgerApiV2.TxOutRef ->LedgerApiV2.CurrencySymbol -> P.IO ()
-- deploy_Protocol path protocolName protocolPolicyID_TxOutRef tokenEmergencyAdminPolicy_CS = do
--     ------------------------------
--     SystemDirectory.removePathForcibly (path SystemFilePathPosix.</> protocolName)
--     SystemDirectory.createDirectoryIfMissing True (path SystemFilePathPosix.</> protocolName)
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating Protocol Deploy File..."
--     ------------------------------
--     P.putStrLn $ "Path: " ++ path SystemFilePathPosix.</> protocolName
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating 'Protocol PolicyID' Script..."
--     MonadIOClass.liftIO $ P.putStrLn $ "Protocol PolicyID TxOutRef: " ++ P.show protocolPolicyID_TxOutRef
--     ------------------------------
--     let protocolPolicyParams =
--             ProtocolT.PolicyParams
--                 {
--                     ProtocolT.ppProtocolPolicyID_TxOutRef = protocolPolicyID_TxOutRef
--                 }
--         protocolPolicyID = ProtocolOnChain.policyID protocolPolicyParams
--         protocolPolicyID_CS = OffChainHelpers.getCurSymbolOfPolicy protocolPolicyID
--     MonadIOClass.liftIO $ P.putStrLn $ "Protocol PolicyParams: " ++ P.show protocolPolicyParams
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployMintingPolicy (path SystemFilePathPosix.</> protocolName) "ProtocolPolicyID" protocolPolicyID protocolPolicyID_CS
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating 'Protocol Validator' Script..."
--     let protocolValidatorParams =
--             ProtocolT.ValidatorParams
--                     {
--                         ProtocolT.vpProtocolPolicyID_CS = protocolPolicyID_CS,
--                         ProtocolT.vpTokenEmergencyAdminPolicy_CS = tokenEmergencyAdminPolicy_CS
--                     }
--         protocolValidator = ProtocolOnChain.validator protocolValidatorParams
--         protocolValidator_Hash = OffChainHelpers.hashValidator protocolValidator
--         protocolValidator_Address = OffChainHelpers.addressValidator protocolValidator_Hash
--     MonadIOClass.liftIO $ P.putStrLn $ "Protocol ValidatorParams: " ++ P.show protocolValidatorParams
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidator (path SystemFilePathPosix.</> protocolName) "ProtocolValidator" protocolValidator
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorHash (path SystemFilePathPosix.</> protocolName) "ProtocolValidator" protocolValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorAddress (path SystemFilePathPosix.</> protocolName) "ProtocolValidator" protocolValidator_Address
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating 'Script PolicyID' Script..."
--     let scriptPolicyParams =
--             ScriptT.PolicyParams
--                     {
--                         ScriptT.ppProtocolPolicyID_CS = protocolPolicyID_CS
--                     }
--         scriptPolicyID = ScriptOnChain.policyID scriptPolicyParams
--         scriptPolicyID_CS = OffChainHelpers.getCurSymbolOfPolicy scriptPolicyID
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployMintingPolicy (path SystemFilePathPosix.</> protocolName) "ScriptPolicyID" scriptPolicyID scriptPolicyID_CS
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating 'Script Validator' Script..."
--     let scriptValidatorParams =
--             ScriptT.ValidatorParams
--                     {
--                         ScriptT.vpScriptPolicyID_CS = scriptPolicyID_CS,
--                         ScriptT.vpProtocolPolicyID_CS = protocolPolicyID_CS
--                     }
--         scriptValidator = ScriptOnChain.validator scriptValidatorParams
--         scriptValidator_Hash = OffChainHelpers.hashValidator scriptValidator
--         scriptValidator_Address = OffChainHelpers.addressValidator scriptValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidator (path SystemFilePathPosix.</> protocolName) "ScriptValidator" scriptValidator
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorHash (path SystemFilePathPosix.</> protocolName) "ScriptValidator" scriptValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorAddress (path SystemFilePathPosix.</> protocolName) "ScriptValidator" scriptValidator_Address
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating 'Campaign Validator' Script..."
--     let campaignValidatorParams =
--             CampaignT.ValidatorParams
--                 {
--                     CampaignT.vpProtocolPolicyID_CS = protocolPolicyID_CS,
--                     CampaignT.vpTokenEmergencyAdminPolicy_CS = tokenEmergencyAdminPolicy_CS
--                 }
--         campaignValidator = CampaignOnChain.validator campaignValidatorParams
--         campaignValidator_Hash = OffChainHelpers.hashValidator campaignValidator
--         campaignValidator_Address = OffChainHelpers.addressValidator campaignValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidator (path SystemFilePathPosix.</> protocolName) "CampaignValidator" campaignValidator
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorHash (path SystemFilePathPosix.</> protocolName) "CampaignValidator" campaignValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorAddress (path SystemFilePathPosix.</> protocolName) "CampaignValidator" campaignValidator_Address
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Generating 'CampaignFunds Validator ' Script..."
--     let campaignFundsValidatorParams =
--             CampaignFundsT.ValidatorParams
--                 {
--                     CampaignFundsT.vpProtocolPolicyID_CS = protocolPolicyID_CS,
--                     CampaignFundsT.vpTokenEmergencyAdminPolicy_CS = tokenEmergencyAdminPolicy_CS
--                 }
--         campaignFundsValidator = CampaignFundsOnChain.validator campaignFundsValidatorParams
--         campaignFundsValidator_Hash = OffChainHelpers.hashValidator campaignFundsValidator
--         campaignFundsValidator_Address = OffChainHelpers.addressValidator campaignFundsValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidator (path SystemFilePathPosix.</> protocolName) "CampaignFundsValidator" campaignFundsValidator
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorHash (path SystemFilePathPosix.</> protocolName) "CampaignFundsValidator" campaignFundsValidator_Hash
--     _ <- MonadIOClass.liftIO $ DeployHelpers.deployValidatorAddress (path SystemFilePathPosix.</> protocolName) "CampaignFundsValidator" campaignFundsValidator_Address
--     ------------------------------
--     protocolPolicyID_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ProtocolPolicyID.plutus")
--     protocolValidator_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ProtocolValidator.plutus")
--     protocolValidator_Address_Testnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ProtocolValidator-Testnet.addr")
--     protocolValidator_Address_Mainnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ProtocolValidator-Mainnet.addr")
--     ------------------------------
--     scriptPolicyID_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ScriptPolicyID.plutus")
--     scriptValidator_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ScriptValidator.plutus")
--     scriptValidator_Address_Testnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ScriptValidator-Testnet.addr")
--     scriptValidator_Address_Mainnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ScriptValidator-Mainnet.addr")
--     ------------------------------
--     campaignValidator_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "CampaignValidator.plutus")
--     campaignValidator_Address_Testnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "CampaignValidator-Testnet.addr")
--     campaignValidator_Address_Mainnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "CampaignValidator-Mainnet.addr")
--     ------------------------------
--     campaignFundsValidator_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "CampaignFundsValidator.plutus")
--     campaignFundsValidator_Address_Testnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "CampaignFundsValidator-Testnet.addr")
--     campaignFundsValidator_Address_Mainnet <- OffChainHelpers.readFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "CampaignFundsValidator-Mainnet.addr")
--     ------------------------------
--     MonadIOClass.liftIO $ P.putStrLn "Creating Protocol Deploy File..."
--     ------------------------------
--     let protocolDeployParams =
--             ProtocolDeployParams {
--                 pdpProtocolVersion = T.protocolVersion,
--                 pdpTokenEmergencyAdmin_CS = tokenEmergencyAdminPolicy_CS,
--                 pdpProtocolPolicyID_Params = protocolPolicyParams,
--                 pdpProtocolPolicyID_CborHex = OffChainHelpers.lazyByteStringToString protocolPolicyID_CborHex,
--                 pdpProtocolPolicyID_CS = protocolPolicyID_CS,
--                 pdpProtocolValidator_Params = protocolValidatorParams,
--                 pdpProtocolValidator_Hash = protocolValidator_Hash,
--                 pdpProtocolValidator_CborHex = OffChainHelpers.lazyByteStringToString protocolValidator_CborHex,
--                 pdpProtocolValidator_AddressTestnet = OffChainHelpers.lazyByteStringToString protocolValidator_Address_Testnet,
--                 pdpProtocolValidator_AddressMainnet = OffChainHelpers.lazyByteStringToString protocolValidator_Address_Mainnet,
--                 pdpScriptPolicyID_Params          = scriptPolicyParams,
--                 pdpScriptPolicyID_CborHex         = OffChainHelpers.lazyByteStringToString scriptPolicyID_CborHex,
--                 pdpScriptPolicyID_CS              = scriptPolicyID_CS,
--                 pdpScriptValidator_Params         = scriptValidatorParams,
--                 pdpScriptValidator_Hash           = scriptValidator_Hash,
--                 pdpScriptValidator_CborHex        = OffChainHelpers.lazyByteStringToString scriptValidator_CborHex,
--                 pdpScriptValidator_AddressTestnet = OffChainHelpers.lazyByteStringToString scriptValidator_Address_Testnet,
--                 pdpScriptValidator_AddressMainnet = OffChainHelpers.lazyByteStringToString scriptValidator_Address_Mainnet,
--                 pdpCampaignValidator_Params          = campaignValidatorParams,
--                 pdpCampaignValidator_Hash            = campaignValidator_Hash,
--                 pdpCampaignValidator_CborHex         = OffChainHelpers.lazyByteStringToString campaignValidator_CborHex,
--                 pdpCampaignValidator_AddressTestnet  = OffChainHelpers.lazyByteStringToString campaignValidator_Address_Testnet,
--                 pdpCampaignValidator_AddressMainnet  = OffChainHelpers.lazyByteStringToString campaignValidator_Address_Mainnet ,
--                 pdpCampaignFundsValidator_Params          = campaignFundsValidatorParams,
--                 pdpCampaignFundsValidator_Hash            = campaignFundsValidator_Hash,
--                 pdpCampaignFundsValidator_CborHex         = OffChainHelpers.lazyByteStringToString campaignFundsValidator_CborHex,
--                 pdpCampaignFundsValidator_AddressTestnet  = OffChainHelpers.lazyByteStringToString campaignFundsValidator_Address_Testnet,
--                 pdpCampaignFundsValidator_AddressMainnet  = OffChainHelpers.lazyByteStringToString campaignFundsValidator_Address_Mainnet
--             }
--     OffChainHelpers.writeEncodedToFile (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ProtocolDeploy.json") protocolDeployParams
--     ------------------------------
--     P.putStrLn $ "Saved Protocol Deploy in: " ++ P.show (path SystemFilePathPosix.</> protocolName SystemFilePathPosix.</> "ProtocolDeploy.json")
--     P.putStrLn "--------------------------------"
--     ------------------------------

-- deploy_CampaignFactory :: P.FilePath -> P.String ->  P.IO ()
-- deploy_CampaignFactory path campaignFactoryName =
--     do
--         SystemDirectory.removePathForcibly (path SystemFilePathPosix.</> campaignFactoryName)
--         SystemDirectory.createDirectoryIfMissing True (path SystemFilePathPosix.</> campaignFactoryName)
--         ------------------------------
--         MonadIOClass.liftIO $ P.putStrLn "Generating Campaign Factory Deploy File..."
--         ------------------------------
--         MonadIOClass.liftIO $ P.putStrLn $ "Path: " ++ path SystemFilePathPosix.</> campaignFactoryName
--         ------------------------------
--         MonadIOClass.liftIO $ P.putStrLn "Generating 'Campaign Policy' Pre-Script..."
--         let campaignPolicy =  Plutonomy.optimizeUPLC  CampaignOnChain.policyCode
--         DeployHelpers.writeCompiledCodeToJsonFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignPolicy_PRE.plutus") campaignPolicy
--         -- DeployHelpers.writeCompiledCodeToBinaryFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignPolicy_PRE.serialized") campaignPolicy
--         ------------------------------
--         MonadIOClass.liftIO $ P.putStrLn "Generating 'CampaignFunds PolicyID' Pre-Script..."
--         let campaignFundsPolicyID =  Plutonomy.optimizeUPLC  CampaignFundsOnChain.policyIDCode
--         DeployHelpers.writeCompiledCodeToJsonFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignFundsPolicyID_PRE.plutus") campaignFundsPolicyID
--         -- DeployHelpers.writeCompiledCodeToBinaryFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignFundsPolicyID_PRE.serialized") campaignFundsPolicyID
--         ------------------------------
--         MonadIOClass.liftIO $ P.putStrLn "--------------------------------"
--         MonadIOClass.liftIO $ P.putStrLn "Creating Campaign Factory Deploy File..."
--         ------------------------------
--         campaignPolicy_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignPolicy_PRE.plutus")
--         campaignFundsPolicyID_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignFundsPolicyID_PRE.plutus")
--         ------------------------------
--         let campaignFactoryDeployParams =
--                 CampaignFactoryDeployParams {
--                     ffdpCampaignVersion                 = T.campaignVersion,
--                     ffdpCampaignPolicy_Pre_CborHex           = OffChainHelpers.lazyByteStringToString  campaignPolicy_Pre_CborHex,
--                     ffdpCampaignFundsPolicyID_Pre_CborHex    = OffChainHelpers.lazyByteStringToString  campaignFundsPolicyID_Pre_CborHex
--                 }
--         OffChainHelpers.writeEncodedToFile (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignFactoryDeploy.json") campaignFactoryDeployParams
--         ------------------------------
--         P.putStrLn $ "Saved Campaign Factory Deploy in: " ++ P.show (path SystemFilePathPosix.</> campaignFactoryName SystemFilePathPosix.</> "CampaignFactoryDeploy.json")
--         P.putStrLn "--------------------------------"
--         ------------------------------

------------------------------------------------------------------------------2

deploy_PRE_script ::  P.FilePath -> P.String -> Bool -> PlutusTx.CompiledCode a -> P.IO ()
deploy_PRE_script filePath name swOverWrite code = do
    fileExists <- SystemDirectory.doesFileExist filePath
    if fileExists && not swOverWrite
        then do
            MonadIOClass.liftIO $ P.putStrLn $ "Reading '" ++ name ++ "' Pre-Script..."
        else do
            MonadIOClass.liftIO $ P.putStrLn $ "Generating '" ++ name ++ "' Pre-Script..."
            -- let !optimizedCode = Plutonomy.optimizeUPLC code
            let optimizedCode = code
            -- DeployHelpers.writeCompiledCodeToBinaryFile filePath optimizedCode
            DeployHelpers.writeCompiledCodeToJsonFile filePath optimizedCode

------------------------------------------------------------------------------2

-- Para obtener deploy file de fabrica de protocolo y de fondo incluido
deploy_ProtocolFactory_And_CampaingFactory_ :: P.IO ProtocolAndCampaignFactoryDeployParams
deploy_ProtocolFactory_And_CampaingFactory_ = do
    ------------------------------
    let
        version = T.mkVersionWithDependency [ProtocolT.protocolVersion, CampaignT.campaignVersion, ScriptT.scriptVersion] 0
        path = "export/protocol-v" ++ P.show version
    ------------------------------
    -- Get the current time
    currentTime <- MonadIOClass.liftIO DataTime.getCurrentTime
    -- Format the time. "%Y-%m-%d-%H-%M" corresponds to "yyyy-mm-dd-hh-mm"
    let
        defaultName = DataTime.formatTime DataTime.defaultTimeLocale "%Y-%m-%d-%H-%M" currentTime
    ------------------------------
    P.putStrLn $ "Protocol Name (default=" ++ defaultName ++ "):"
    !protocolName <- MonadIOClass.liftIO $ CLIHelpers.getStrWithDefault defaultName
    ------------------------------
    let
        finalPath = path SystemFilePathPosix.</> protocolName
    ------------------------------
    SystemDirectory.removePathForcibly finalPath
    ------------------------------
    deploy_ProtocolFactory_And_CampaingFactory path protocolName True

------------------------------

deploy_ProtocolFactory_And_CampaingFactory ::  P.FilePath -> P.String -> Bool -> P.IO ProtocolAndCampaignFactoryDeployParams
deploy_ProtocolFactory_And_CampaingFactory path name swOverWrite = do
    ------------------------------
    -- SystemDirectory.removePathForcibly (path SystemFilePathPosix.</> name)
    SystemDirectory.createDirectoryIfMissing True (path SystemFilePathPosix.</> name)
    ------------------------------
    MonadIOClass.liftIO $ P.putStrLn "Generating Deploy Files..."
    ------------------------------
    MonadIOClass.liftIO $ P.putStrLn $ "Path: " ++ path SystemFilePathPosix.</> name
    ------------------------------
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ProtocolPolicyID_PRE.plutus") "ProtocolPolicyID" swOverWrite ProtocolOnChain.policyIDCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ProtocolValidator_PRE.plutus") "ProtocolValidator" swOverWrite ProtocolOnChain.validatorCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ScriptPolicyID_PRE.plutus") "ScriptPolicyID" swOverWrite ScriptOnChain.policyIDCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ScriptValidator_PRE.plutus") "ScriptValidator" swOverWrite ScriptOnChain.validatorCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignPolicy_PRE.plutus") "CampaignPolicy" swOverWrite CampaignOnChain.policyCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignValidator_PRE.plutus") "CampaignValidator" swOverWrite CampaignOnChain.validatorCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignFundsPolicyID_PRE.plutus") "CampaignFundsPolicyID" swOverWrite CampaignFundsOnChain.policyIDCode
    deploy_PRE_script (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignFundsValidator_PRE.plutus") "CampaignFundsValidator" swOverWrite CampaignFundsOnChain.validatorCode
    ------------------------------
    MonadIOClass.liftIO $P.putStrLn "--------------------------------"
    ------------------------------
    protocolPolicyID_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ProtocolPolicyID_PRE.plutus")
    protocolValidator_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ProtocolValidator_PRE.plutus")
    scriptPolicyID_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ScriptPolicyID_PRE.plutus")
    scriptValidator_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "ScriptValidator_PRE.plutus")
    campaignPolicy_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignPolicy_PRE.plutus")
    campaignValidator_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignValidator_PRE.plutus")
    campaignFundsPolicyID_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignFundsPolicyID_PRE.plutus")
    campaignFundsValidator_Pre_CborHex <- OffChainHelpers.readFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "CampaignFundsValidator_PRE.plutus")
    ------------------------------
    let deployAllPreParams =
                ProtocolAndCampaignFactoryDeployParams {
                    fdpProtocolVersion  = ProtocolT.protocolVersion,
                    fdpCampaignVersion                 = CampaignT.campaignVersion,
                    fdpScriptVersion                   = ScriptT.scriptVersion,
                    fdpProtocolPolicyID_Pre_CborHex    = OffChainHelpers.lazyByteStringToString protocolPolicyID_Pre_CborHex,
                    fdpProtocolValidator_Pre_CborHex   = OffChainHelpers.lazyByteStringToString protocolValidator_Pre_CborHex,
                    fdpScriptPolicyID_Pre_CborHex      = OffChainHelpers.lazyByteStringToString scriptPolicyID_Pre_CborHex,
                    fdpScriptValidator_Pre_CborHex     = OffChainHelpers.lazyByteStringToString scriptValidator_Pre_CborHex,
                    fdpCampaignPolicy_Pre_CborHex           = OffChainHelpers.lazyByteStringToString  campaignPolicy_Pre_CborHex,
                    fdpCampaignValidator_Pre_CborHex = OffChainHelpers.lazyByteStringToString  campaignValidator_Pre_CborHex,
                    fdpCampaignFundsPolicyID_Pre_CborHex    = OffChainHelpers.lazyByteStringToString  campaignFundsPolicyID_Pre_CborHex,
                    fdpCampaignFundsValidator_Pre_CborHex   = OffChainHelpers.lazyByteStringToString  campaignFundsValidator_Pre_CborHex
                }
    ------------------------------
    OffChainHelpers.writeEncodedToFile (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "deploy.json") deployAllPreParams
    ------------------------------
    P.putStrLn $ "Saved Deploy File in: " ++ P.show (path SystemFilePathPosix.</> name SystemFilePathPosix.</> "deploy.json")
    P.putStrLn "--------------------------------"
    ------------------------------
    return deployAllPreParams

------------------------------------------------------------------------------2

loadFactoryDeployParams :: SystemFilePathPosix.FilePath -> Bool -> P.IO (Maybe ProtocolAndCampaignFactoryDeployParams)
loadFactoryDeployParams filePath swOverWrite = do
    fileExists <- SystemDirectory.doesFileExist filePath
    if fileExists && not swOverWrite
        then do
            OffChainHelpers.readDecodedFromFile filePath
        else do
            deployParams <- deploy_ProtocolFactory_And_CampaingFactory "export" "test" False
            return $ Just deployParams

------------------------------------------------------------------------------2

====== Others/PolicyFT.hs ======

{-# LANGUAGE DataKinds        #-}
{-# LANGUAGE RecordWildCards  #-}
{-# LANGUAGE TemplateHaskell  #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies     #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Others.PolicyFT where

--------------------------------------------------------------------------------2
-- External Imports
--------------------------------------------------------------------------------2

import qualified Plutonomy
import qualified Plutus.V2.Ledger.Api       as LedgerApiV2
import qualified PlutusTx
import qualified PlutusTx.Builtins.Internal as TxBuiltinsInternal (BuiltinInteger)
import           PlutusTx.Prelude           (BuiltinData, Integer, error, ($), (>))

--------------------------------------------------------------------------------2
-- Internal Imports
--------------------------------------------------------------------------------2

--------------------------------------------------------------------------------2
-- Module
--------------------------------------------------------------------------------2

{-# INLINEABLE mkPolicyFT #-}
mkPolicyFT :: TxBuiltinsInternal.BuiltinInteger -> BuiltinData -> BuiltinData -> ()
mkPolicyFT numero _ _ =
    if numero > 0 then () else error ()

--------------------------------------------------------------------------------2

{-# INLINEABLE policyFT #-}
policyFT :: Integer -> LedgerApiV2.MintingPolicy
policyFT numero =
    Plutonomy.optimizeUPLC $
        Plutonomy.mintingPolicyToPlutus $
            Plutonomy.mkMintingPolicyScript $
                $$(PlutusTx.compile [||mkPolicyFT||])
                    `PlutusTx.applyCode` PlutusTx.liftCode numero

--------------------------------------------------------------------------------2

====== Others/PolicyNFT.hs ======

{-# LANGUAGE DataKinds        #-}
{-# LANGUAGE RecordWildCards  #-}
{-# LANGUAGE TemplateHaskell  #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies     #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Others.PolicyNFT where

--------------------------------------------------------------------------------2
-- External Imports
--------------------------------------------------------------------------------2

import qualified Ledger.Value              as LedgerValue
import qualified Plutonomy
import qualified Plutus.V2.Ledger.Api      as LedgerApiV2
import qualified Plutus.V2.Ledger.Contexts as LedgerContextsV2
import qualified PlutusTx
import           PlutusTx.Prelude

--------------------------------------------------------------------------------2
-- Internal Imports
--------------------------------------------------------------------------------2

--------------------------------------------------------------------------------2
-- Module
--------------------------------------------------------------------------------2

{-# INLINEABLE mkPolicyNFT #-}
mkPolicyNFT :: LedgerApiV2.TxOutRef -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ()
mkPolicyNFT oref _ !ctxRaw =
    if traceIfFalse "UTxO not consumed" hasInputUTxO
        && traceIfFalse "Wrong amount minted" checkMintingAmount
        then ()
        else error ()
    where
        !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        ------------------
        info :: LedgerContextsV2.TxInfo
        info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
        hasInputUTxO :: Bool
        hasInputUTxO = any (\i -> LedgerApiV2.txInInfoOutRef i == oref) $ LedgerApiV2.txInfoInputs info
        ------------------
        !cs = LedgerContextsV2.ownCurrencySymbol ctx
        ------------------
        checkMintingAmount :: Bool
        checkMintingAmount = allOnes (LedgerValue.flattenValue (LedgerApiV2.txInfoMint info))
        -- case LedgerValueV1.flattenValue (LedgerApiV1.txInfoMint info) of
        --     [(cs, tn', amt)] -> tn' == tn &&
        --                        amt == 1
        --     _               -> False
        ------------------
        allOnes :: [(LedgerValue.CurrencySymbol, b, Integer)] -> Bool
        allOnes lst = all (\(cs', _, amt) -> cs' == cs && amt == 1) lst

--------------------------------------------------------------------------------2

{-# INLINEABLE policyNFT #-}
policyNFT :: LedgerApiV2.TxOutRef -> LedgerApiV2.MintingPolicy
policyNFT oref =
    Plutonomy.optimizeUPLC $
        Plutonomy.mintingPolicyToPlutus $
            Plutonomy.mkMintingPolicyScript $
                $$(PlutusTx.compile [||mkPolicyNFT||])
                    `PlutusTx.applyCode` PlutusTx.liftCode oref

--------------------------------------------------------------------------------2

====== Protocol/Helpers.hs ======

{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE RankNTypes          #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies        #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Protocol.Helpers where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import           PlutusTx.Prelude

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Helpers.Types        as T
import qualified Protocol.Types       as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Protocol_Datum_With_NormalChanges #-}
mkUpdated_Protocol_Datum_With_NormalChanges :: T.ProtocolDatumType ->
    [T.WalletPaymentPKH] -> LedgerApiV2.CurrencySymbol -> T.ProtocolDatumType
mkUpdated_Protocol_Datum_With_NormalChanges !protocolDatum_In !admins !tokenAdminPolicy_CS  =
    protocolDatum_In {
        T.pdAdmins = admins,
        T.pdTokenAdminPolicy_CS = tokenAdminPolicy_CS
    }

--------------------------------------------------------------------------------2

{-# INLINEABLE mkUpdated_Protocol_Datum_With_MinADAChanged #-}
mkUpdated_Protocol_Datum_With_MinADAChanged :: T.ProtocolDatumType -> Integer -> T.ProtocolDatumType
mkUpdated_Protocol_Datum_With_MinADAChanged !protocolDatum_In !newMinADA =
    protocolDatum_In {
        T.pdMinADA = newMinADA
    }

--------------------------------------------------------------------------------2

====== Protocol/OnChain.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
--------------------------------------------------------------------------------2
-- UNCOMMENT THIS CODE TO CREATE A PROFILE LOGS WITHIN THE SCRIPT
-- {-# OPTIONS_GHC -g #-}
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:profile-all #-}
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:conservative-optimisation #-}
-- THIS ADD TO LOGS BUT CANT BE PARSED BY traceToStacks
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:coverage-all #-}
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:coverage-boolean #-}
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:coverage-location #-}
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:no-optimize #-}
-- {-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:verbosity=1 #-}
--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
{- HLINT ignore "Reduce duplication"          -}
--------------------------------------------------------------------------------2

module Protocol.OnChain where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Ledger.Ada                 as LedgerAda
import qualified Ledger.Value               as LedgerValue
import qualified Plutonomy
import qualified Plutus.V2.Ledger.Api       as LedgerApiV2
import qualified Plutus.V2.Ledger.Contexts  as LedgerContextsV2
import qualified PlutusTx
import qualified PlutusTx.Builtins.Internal as BI
import           PlutusTx.Prelude

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Constants                  as T
import qualified Helpers.OnChain            as OnChainHelpers
import qualified Protocol.Helpers           as ProtocolHelpers
import qualified Protocol.Types             as T
import qualified Types                      as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

{-# INLINEABLE mkPolicyID #-}
mkPolicyID :: T.PolicyParams ->   BuiltinData -> BuiltinData -> ()
mkPolicyID (T.PolicyParams !protocolPolicyID_TxOutRef) _ !ctxRaw =
    if traceIfFalse "" useThisToMakeScriptUnique
        && traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange info T.validTxTimeRange)
        && validateRedeemer
        then ()
        else error ()
    where
        ------------------
        !useThisToMakeScriptUnique = True
        ------------------
        !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
        !protocolPolicyID_CS = LedgerContextsV2.ownCurrencySymbol ctx
        ------------------
        !protocolID_AC = LedgerValue.AssetClass (protocolPolicyID_CS, T.protocolID_TN)
        ------------------
        !valueFor_Mint_ProtocolID = LedgerValue.assetClassValue protocolID_AC 1
        ------------------
        isMintingID :: Bool
        !isMintingID = OnChainHelpers.getUnsafeOwnMintingValue ctx `OnChainHelpers.isEqValue` valueFor_Mint_ProtocolID
        -----------------
        !outputs_txOuts =
            [ txOut | txOut <- LedgerApiV2.txInfoOutputs info, OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress txOut)
            ]
        ------------------
        !_ = case outputs_txOuts of
            [] -> traceError "Expected at least one output to scripts addresses"
            _  -> ()
        ------------------
        -- 0 out is the ProtocolDatum
        ------------------
        !output_TxOut_And_ProtocolDatum =
            fromMaybe
                (traceError "Expected Protocol at output to script index 0")
                ( OnChainHelpers.getTxOut_And_DatumType_From_TxOut_And_AC_And_Address
                    @T.ValidatorDatum
                    @T.ProtocolDatumType
                    ctx
                    (head outputs_txOuts)
                    protocolID_AC
                    Nothing
                    T.getProtocol_DatumType
                )
        ------------------
        !protocolDatum_Out = OnChainHelpers.getDatum_In_TxOut_And_Datum output_TxOut_And_ProtocolDatum
        ---------------------
        !minADA_For_ProtocolDatum = T.pdMinADA protocolDatum_Out
        !value_MinADA_For_ProtocolDatum = LedgerAda.lovelaceValueOf minADA_For_ProtocolDatum
        !valueFor_ProtocolDatum_Out_Control = valueFor_Mint_ProtocolID <> value_MinADA_For_ProtocolDatum
        ---------------------
        !protocolDatum_Out_Control =
            T.mkProtocol_DatumType
                (T.pdAdmins protocolDatum_Out)
                (T.pdTokenAdminPolicy_CS protocolDatum_Out)
                minADA_For_ProtocolDatum
        ---------------------
        isCorrect_Output_Protocol_Datum :: Bool
        !isCorrect_Output_Protocol_Datum =
            protocolDatum_Out

                `OnChainHelpers.isUnsafeEqDatums` protocolDatum_Out_Control
                ------------------
        isCorrect_Output_Protocol_Datum_Value :: Bool
        !isCorrect_Output_Protocol_Datum_Value =
            let
                !valueOf_ProtocolDatum_Out = OnChainHelpers.getValue_In_TxOut_And_Datum output_TxOut_And_ProtocolDatum
            in
                valueOf_ProtocolDatum_Out `OnChainHelpers.isEqValue` valueFor_ProtocolDatum_Out_Control
        -----------------
        validateRedeemer :: Bool
        validateRedeemer =
            -----------------
            -- Que se consuma utxo en parámetro de la póliza
            -- Que se este minteando NFT con el nombre correcto
            -----------------
            traceIfFalse "not isTxOutAnInput" (OnChainHelpers.isTxOutAnInput protocolPolicyID_TxOutRef info)
                && traceIfFalse "not isMintingID" isMintingID
                && traceIfFalse "not isCorrect_Output_Protocol_Datum" isCorrect_Output_Protocol_Datum
                && traceIfFalse "not isCorrect_Output_Protocol_Datum_Value" isCorrect_Output_Protocol_Datum_Value

--------------------------------------------------------------------------------2

{-# INLINEABLE mkValidator #-}
mkValidator :: T.ValidatorParams -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkValidator (T.ValidatorParams !protocolPolicyID_CS !tokenEmergencyAdminPolicy_CS) !datumRaw !redRaw !ctxRaw =
    let
        ------------------
        parseData ::PlutusTx.FromData a =>  BuiltinData -> BuiltinString -> a
        parseData d s = case PlutusTx.fromBuiltinData  d of
            Just d_ -> d_
            _       -> traceError s
        ------------------
        dataToListData :: BuiltinData -> BI.BuiltinList BuiltinData
        dataToListData bd = BI.snd (BI.unsafeDataAsConstr bd)
        ------------------
        ctxListRaw :: BI.BuiltinList BuiltinData
        !ctxListRaw = dataToListData ctxRaw
        ------------------
        infoListRaw  :: BI.BuiltinList BuiltinData
        !infoListRaw  = dataToListData $ BI.head ctxListRaw
        ------------------
        txInfoInputsRaw :: BuiltinData
        !txInfoInputsRaw = BI.head infoListRaw
        txInfoReferenceInputsPlusTail :: BI.BuiltinList BuiltinData
        !txInfoReferenceInputsPlusTail = BI.tail infoListRaw
        -- txInfoReferenceInputsRaw :: BuiltinData
        -- !txInfoReferenceInputsRaw = BI.head txInfoReferenceInputsPlusTail
        txInfoOutputsPlusTail :: BI.BuiltinList BuiltinData
        !txInfoOutputsPlusTail = BI.tail txInfoReferenceInputsPlusTail
        txInfoOutputsRaw :: BuiltinData
        !txInfoOutputsRaw = BI.head txInfoOutputsPlusTail
        -- Skipping txInfoFee
        txInfoMintPlusTail :: BI.BuiltinList BuiltinData
        !txInfoMintPlusTail = BI.tail (BI.tail txInfoOutputsPlusTail)
        -- txInfoMintRaw :: BuiltinData
        -- !txInfoMintRaw = BI.head txInfoMintPlusTail
        -- Skipping txInfoDCert and txInfoWdrl
        txInfoValidRangePlusTail :: BI.BuiltinList BuiltinData
        !txInfoValidRangePlusTail = BI.tail (BI.tail (BI.tail txInfoMintPlusTail))
        txInfoValidRangeRaw :: BuiltinData
        !txInfoValidRangeRaw = BI.head txInfoValidRangePlusTail
        txInfoSignatoriesPlusTail :: BI.BuiltinList BuiltinData
        !txInfoSignatoriesPlusTail = BI.tail txInfoValidRangePlusTail
        txInfoSignatoriesRaw :: BuiltinData
        !txInfoSignatoriesRaw = BI.head txInfoSignatoriesPlusTail
        ------------------
        !txInfoInputs = parseData @[LedgerContextsV2.TxInInfo] txInfoInputsRaw "txInfoInputs: Invalid type"
        -- !txInfoReferenceInputs = parseData @[LedgerContextsV2.TxInInfo] txInfoReferenceInputsRaw "txInfoReferenceInputs: Invalid type"
        !txInfoOutputs = parseData @[LedgerApiV2.TxOut] txInfoOutputsRaw "txInfoOutputs: Invalid type"
        -- !txInfoMint = parseData @LedgerApiV2.Value txInfoMintRaw "txInfoMint: Invalid type"
        !txInfoValidRange = parseData @LedgerApiV2.POSIXTimeRange txInfoValidRangeRaw "txInfoValidRange: Invalid type"
        !txInfoSignatories = parseData @[LedgerApiV2.PubKeyHash] txInfoSignatoriesRaw "txInfoSignatories: Invalid type"
        ------------------
        scriptContextPurposeRaw :: BuiltinData
        !scriptContextPurposeRaw = BI.head $ BI.tail ctxListRaw
        ------------------
        scriptContextPurpose = parseData @LedgerContextsV2.ScriptPurpose scriptContextPurposeRaw "scriptContextPurpose: Invalid type"
        ------------------
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.ValidatorRedeemer redRaw
        -- !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        -- !info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
        -- Si esta el token de emergencia se saltea todos los controles
        isEmergencyRedeemer :: Bool
        !isEmergencyRedeemer =
            case redeemer of
                (T.ValidatorRedeemerEmergency _) -> True
                _                                -> False
    in
        ------------------
        case isEmergencyRedeemer of
            True ->
                let
                    !tokenEmergencyAdmin_AC = LedgerValue.AssetClass (tokenEmergencyAdminPolicy_CS, T.tokenEmergencyAdmin_TN)
                    -- search emergency admin token in output 0
                    !isEmergencyAdminTokenPresent = OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue $ head txInfoOutputs) tokenEmergencyAdmin_AC
                in
                    if traceIfFalse "not isEmergencyAdminTokenPresent" isEmergencyAdminTokenPresent
                        then ()
                        else error ()
            False ->
                if traceIfFalse "" useThisToMakeScriptUnique
                    && traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange_V2 txInfoValidRange T.validTxTimeRange)
                    && traceIfFalse "Expected exactly one Protocol input" (length inputs_Own_TxOuts == 1)
                    && (
                         -- Si no, se valida que el que firma sea admin o que este el token admin y luego se valida el redeemer
                         validateAdminAction
                            && validateRedeemerAdmin
                       )
                    then ()
                    else error ()
                where
                    ------------------
                    !useThisToMakeScriptUnique = protocolPolicyID_CS /= LedgerApiV2.adaSymbol
                    ------------------
                    !datum = LedgerApiV2.unsafeFromBuiltinData @T.ValidatorDatum datumRaw
                    ------------------
                    !protocolID_AC = LedgerValue.AssetClass (protocolPolicyID_CS, T.protocolID_TN)
                    ------------------
                    !input_TxOut_BeingValidated = OnChainHelpers.getUnsafe_Own_Input_TxOut_V2 scriptContextPurpose txInfoInputs
                    !protocol_Validator_Address = LedgerApiV2.txOutAddress input_TxOut_BeingValidated
                     ------------------
                    !inputs_Own_TxOuts = [LedgerApiV2.txInInfoResolved txInfoInput | txInfoInput <- txInfoInputs ,
                        let address = LedgerApiV2.txOutAddress (LedgerApiV2.txInInfoResolved txInfoInput)
                        in  OnChainHelpers.isScriptAddress address && address == protocol_Validator_Address]
                    ------------------
                    !outputs_txOuts =
                        [ txOut | txOut <- txInfoOutputs, OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress txOut)
                        ]
                    ------------------
                    !_ = case outputs_txOuts of
                        [] -> traceError "Expected at least one output to scripts addresses"
                        _  -> ()
                    ------------------
                    -- filter only outputs at scripts addresses
                    -- 0 out is the ProtocolDatum
                    ------------------
                    !output_Own_TxOut_And_ProtocolDatum =
                        fromMaybe
                            (traceError "Expected Protocol at output to script index 0")
                            ( OnChainHelpers.getTxOut_And_InlineDatumType_From_TxOut_And_AC_And_Address_V2 @T.ValidatorDatum @T.ProtocolDatumType
                                (head outputs_txOuts)
                                protocolID_AC
                                (Just protocol_Validator_Address)
                                T.getProtocol_DatumType
                            )
                    ------------------
                    !protocolDatum_In = T.getProtocol_DatumType datum
                    ------------------
                    !valueOf_ProtocolDatum_In = LedgerApiV2.txOutValue input_TxOut_BeingValidated
                    ------------------
                    validateAdminAction :: Bool
                    !validateAdminAction =
                        -- Que este el token de admin presente en output 0
                        -- o Que sea Protocol Admin
                        traceIfFalse "not isSignedByAny admins nor isAdminTokenPresent" (OnChainHelpers.isSignedByAny_V2 admins txInfoSignatories || isAdminTokenPresent)
                        where
                            !admins = T.getAdmins protocolDatum_In
                            ------------------
                            isAdminTokenPresent :: Bool
                            isAdminTokenPresent = case txInfoOutputs of
                                []         -> False
                                -- search admin token in output 0
                                (output:_) -> OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue output) tokenAdmin_AC
                                where
                                    !tokenAdminPolicy_CS = T.getAdminToken_CS protocolDatum_In
                                    !tokenAdmin_AC = LedgerValue.AssetClass (tokenAdminPolicy_CS, T.tokenAdmin_TN)
                    ------------------
                    validateRedeemerAdmin :: Bool
                    validateRedeemerAdmin =
                        case redeemer of
                            (T.ValidatorRedeemerDatumUpdate _) ->
                                ------------------
                                -- Que el ProtocolDatum regrese a Protocol Val
                                -- Que el ProtocolDatum se actualiza correctamente
                                -- Que el ProtocolDatum value no cambie
                                ------------------
                                traceIfFalse "not isCorrect_Output_Protocol_Datum_Updated" isCorrect_Output_Protocol_Datum_Updated
                                    && traceIfFalse "not isCorrect_Output_Protocol_Datum_Value_NotChanged" isCorrect_Output_Protocol_Datum_Value_NotChanged
                                where
                                    ---------------------
                                    !protocolDatum_Out = OnChainHelpers.getDatum_In_TxOut_And_Datum output_Own_TxOut_And_ProtocolDatum
                                    ---------------------
                                    !protocolDatum_Out_Control =
                                        ProtocolHelpers.mkUpdated_Protocol_Datum_With_NormalChanges
                                            protocolDatum_In
                                            (T.pdAdmins protocolDatum_Out)
                                            (T.pdTokenAdminPolicy_CS protocolDatum_Out)
                                    ---------------------
                                    isCorrect_Output_Protocol_Datum_Updated :: Bool
                                    !isCorrect_Output_Protocol_Datum_Updated =
                                        protocolDatum_Out
                                            `OnChainHelpers.isUnsafeEqDatums` protocolDatum_Out_Control
                                            ------------------
                                    isCorrect_Output_Protocol_Datum_Value_NotChanged :: Bool
                                    !isCorrect_Output_Protocol_Datum_Value_NotChanged =
                                        let
                                            !valueOf_ProtocolDatum_Out = OnChainHelpers.getValue_In_TxOut_And_Datum output_Own_TxOut_And_ProtocolDatum
                                            !valueFor_ProtocolDatum_Control = valueOf_ProtocolDatum_In
                                        in
                                            valueOf_ProtocolDatum_Out `OnChainHelpers.isEqValue` valueFor_ProtocolDatum_Control
                            (T.ValidatorRedeemerUpdateMinADA _) ->
                                ------------------
                                -- Que el ProtocolDatum regrese a Protocol Val
                                -- Que el ProtocolDatum se actualiza correctamente
                                -- Que el ProtocolDatum value cambie con el min ADA nuevo
                                ------------------
                                    traceIfFalse "not min ADA > 0" (newMinADA > 0)
                                    && traceIfFalse "not isCorrect_Output_Protocol_Datum_UpdatedMinADA" isCorrect_Output_Protocol_Datum_UpdatedMinADA
                                    && traceIfFalse "not isCorrect_Output_Protocol_Datum_Value_ChangedADA" isCorrect_Output_Protocol_Datum_Value_ChangedADA
                                where
                                    ------------------
                                    !protocolDatum_Out = OnChainHelpers.getDatum_In_TxOut_And_Datum output_Own_TxOut_And_ProtocolDatum
                                    ------------------
                                    !newMinADA = T.pdMinADA protocolDatum_Out
                                    ------------------
                                    isCorrect_Output_Protocol_Datum_UpdatedMinADA :: Bool
                                    !isCorrect_Output_Protocol_Datum_UpdatedMinADA =
                                        let
                                            !protocolDatum_Out_Control =
                                                ProtocolHelpers.mkUpdated_Protocol_Datum_With_MinADAChanged
                                                    protocolDatum_In
                                                    newMinADA
                                        in
                                            protocolDatum_Out `OnChainHelpers.isUnsafeEqDatums` protocolDatum_Out_Control
                                    ------------------
                                    isCorrect_Output_Protocol_Datum_Value_ChangedADA :: Bool
                                    !isCorrect_Output_Protocol_Datum_Value_ChangedADA =
                                        let
                                            !valueOf_ProtocolDatum_Out = OnChainHelpers.getValue_In_TxOut_And_Datum output_Own_TxOut_And_ProtocolDatum
                                            !valueFor_ProtocolDatum_Control = valueOf_ProtocolDatum_In <> LedgerAda.lovelaceValueOf (newMinADA - T.pdMinADA protocolDatum_In)
                                        in
                                            valueOf_ProtocolDatum_Out `OnChainHelpers.isEqValue` valueFor_ProtocolDatum_Control
                            _ -> traceIfFalse "incorrect redeemer" False


--------------------------------------------------------------------------------2

{-# INLINEABLE policyID #-}
policyID :: T.PolicyParams -> LedgerApiV2.MintingPolicy
policyID params =
    Plutonomy.optimizeUPLC $
        Plutonomy.mintingPolicyToPlutus $
            Plutonomy.mkMintingPolicyScript $
                $$(PlutusTx.compile [||mkPolicyID||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINEABLE mkWrappedPolicyID #-}
mkWrappedPolicyID :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedPolicyID protocolPolicy_TxHash protocolPolicy_TxOutputIndex = mkPolicyID params
    where
        tid = PlutusTx.unsafeFromBuiltinData protocolPolicy_TxHash :: BuiltinByteString
        txout =
            LedgerApiV2.TxOutRef
                { LedgerApiV2.txOutRefId = LedgerApiV2.TxId tid
                , LedgerApiV2.txOutRefIdx = PlutusTx.unsafeFromBuiltinData protocolPolicy_TxOutputIndex
                }
        params =
            T.PolicyParams
                { ppProtocolPolicyID_TxOutRef = txout
                }

{-# INLINEABLE policyIDCode #-}
policyIDCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())
policyIDCode = Plutonomy.optimizeUPLC $$(PlutusTx.compile [||mkWrappedPolicyID||])

--------------------------------------------------------------------------------2

{-# INLINEABLE validator #-}
validator :: T.ValidatorParams -> LedgerApiV2.Validator
validator params =
    Plutonomy.optimizeUPLC $
        Plutonomy.validatorToPlutus $
            Plutonomy.mkValidatorScript $
                $$(PlutusTx.compile [||mkValidator||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINEABLE mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator protocolPolicyID_CS tokenEmergencyAdminPolicy_CS = mkValidator params
    where
        params =
            T.ValidatorParams
                { vpProtocolPolicyID_CS = PlutusTx.unsafeFromBuiltinData protocolPolicyID_CS
                , vpTokenEmergencyAdminPolicy_CS = PlutusTx.unsafeFromBuiltinData tokenEmergencyAdminPolicy_CS
                }

{-# INLINEABLE validatorCode #-}
validatorCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())
validatorCode = Plutonomy.optimizeUPLC $$(PlutusTx.compile [||mkWrappedValidator||])

--------------------------------------------------------------------------------2

====== Protocol/Types.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE InstanceSigs          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Protocol.Types where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Data.Aeson           as DataAeson (FromJSON, ToJSON)
import qualified Data.OpenApi.Schema  as DataOpenApiSchema (ToSchema)
import qualified GHC.Generics         as GHCGenerics (Generic)
import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import qualified PlutusTx
import           PlutusTx.Prelude
import qualified Prelude              as P
import qualified Schema

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Constants            as T
import qualified Helpers.Types        as T
import qualified Types                as T
import qualified Helpers.OnChain as OnChainHelpers

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

-- Any change in the logic, datum or redeemer must change the version of the protocolVersion
protocolVersion :: Integer
protocolVersion = 1

ownVersion :: Integer
ownVersion = T.mkVersionWithDependency [] protocolVersion

--------------------------------------------------------------------------------2
-- Params
--------------------------------------------------------------------------------2

newtype PolicyParams
    = PolicyParams { ppProtocolPolicyID_TxOutRef :: LedgerApiV2.TxOutRef }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

instance Eq PolicyParams where
    {-# INLINABLE (==) #-}
    pp1 == pp2 =
        ppProtocolPolicyID_TxOutRef pp1 == ppProtocolPolicyID_TxOutRef pp2

PlutusTx.makeLift ''PolicyParams

PlutusTx.makeIsDataIndexed ''PolicyParams [('PolicyParams, 0)]

data ValidatorParams
    = ValidatorParams
          { vpProtocolPolicyID_CS          :: T.CS
          , vpTokenEmergencyAdminPolicy_CS :: LedgerApiV2.CurrencySymbol
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

-- instance Schema.ToSchema ValidatorParams where
--     toSchema = Schema.FormSchemaUnit

instance Eq ValidatorParams where
    {-# INLINABLE (==) #-}
    pp1 == pp2 =
        vpProtocolPolicyID_CS pp1 == vpProtocolPolicyID_CS pp2
        && vpTokenEmergencyAdminPolicy_CS pp1 == vpTokenEmergencyAdminPolicy_CS pp2

PlutusTx.makeLift ''ValidatorParams

PlutusTx.makeIsDataIndexed ''ValidatorParams [('ValidatorParams, 0)]

--------------------------------------------------------------------------------2
-- Datums
--------------------------------------------------------------------------------2

data MinMaxDef a
    = MinMaxDef
          { mmdMin :: a
          , mmdMax :: a
          , mmdDef :: a
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

instance (Eq a) => Eq (MinMaxDef a) where
    {-# INLINABLE (==) #-}
    mi1 == mi2 =
        mmdMin mi1 == mmdMin mi2
            && mmdMax mi1 == mmdMax mi2
            && mmdDef mi1 == mmdDef mi2

-- Method to check the range
isInRange :: (Ord a) => MinMaxDef a -> a -> Bool
isInRange mmd value = mmdMin mmd <= value && value <= mmdMax mmd

isValidMinMaxDef :: (Ord a) => MinMaxDef a -> Bool
isValidMinMaxDef mmd = mmdMin mmd <= mmdMax mmd && mmdMin mmd <= mmdDef mmd && mmdDef mmd <= mmdMax mmd

instance DataOpenApiSchema.ToSchema (MinMaxDef Integer)

instance DataOpenApiSchema.ToSchema (MinMaxDef LedgerApiV2.POSIXTime)

PlutusTx.makeIsDataIndexed ''MinMaxDef [('MinMaxDef, 0)]

{-# INLINABLE mkMinMaxDef #-}
mkMinMaxDef :: a -> a -> a -> MinMaxDef a
mkMinMaxDef min' max' def' =
    MinMaxDef {mmdMin = min', mmdMax = max', mmdDef = def'}

--------------------------------------------------------------------------------2

data ProtocolDatumType
    = ProtocolDatumType
          { pdProtocolVersion     :: Integer
          , pdAdmins              :: [T.WalletPaymentPKH]
          , pdTokenAdminPolicy_CS :: LedgerApiV2.CurrencySymbol
          , pdMinADA              :: Integer
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq ProtocolDatumType where
    {-# INLINABLE (==) #-}
    ps1 == ps2 =
        pdProtocolVersion ps1 == pdProtocolVersion ps2
            && pdAdmins ps1 == pdAdmins ps2
            && pdTokenAdminPolicy_CS ps1 == pdTokenAdminPolicy_CS ps2
            && pdMinADA ps1 == pdMinADA ps2

instance T.HasAdmins ProtocolDatumType where
    {-# INLINABLE getAdmins #-}
    getAdmins = pdAdmins

instance T.HasAdminToken ProtocolDatumType where
    {-# INLINABLE getAdminToken_CS #-}
    getAdminToken_CS = pdTokenAdminPolicy_CS

PlutusTx.makeIsDataIndexed ''ProtocolDatumType [('ProtocolDatumType, 0)]

newtype ValidatorDatum
    = ProtocolDatum ProtocolDatumType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq ValidatorDatum where
    {-# INLINABLE (==) #-}
    ProtocolDatum mps1 == ProtocolDatum mps2 = mps1 == mps2

PlutusTx.makeIsDataIndexed ''ValidatorDatum [('ProtocolDatum, 0)]

{-# INLINABLE getProtocol_DatumType #-}
getProtocol_DatumType :: ValidatorDatum -> ProtocolDatumType
getProtocol_DatumType (ProtocolDatum sdType) = sdType

{-# INLINEABLE getProtocol_DatumType_From_UTxO #-}
getProtocol_DatumType_From_UTxO :: LedgerApiV2.TxOut -> ProtocolDatumType
getProtocol_DatumType_From_UTxO utxo = case OnChainHelpers.getInlineDatum_From_TxOut @ValidatorDatum utxo of
                    Nothing     -> P.error "No Protocol Datum found"
                    Just datum' -> getProtocol_DatumType datum'
                    
instance T.ShowDatum ValidatorDatum where
    showCborAsDatumType cbor =
        case LedgerApiV2.fromBuiltinData @ValidatorDatum cbor of
            Nothing -> Nothing
            Just d  -> Just $ P.show d

--------------------------------------------------------------------------------2
{-# INLINABLE mkProtocol_DatumType #-}
mkProtocol_DatumType ::
    [T.WalletPaymentPKH]
    -> LedgerApiV2.CurrencySymbol
    -> Integer
    -> ProtocolDatumType
mkProtocol_DatumType
    admins
    tokenAdminPolicy_CS
    minADA =
        let !adminsOrdered = sort admins
        in ProtocolDatumType
                { pdProtocolVersion = ownVersion
                , pdAdmins = adminsOrdered
                , pdTokenAdminPolicy_CS = tokenAdminPolicy_CS
                , pdMinADA = minADA
                }

{-# INLINABLE mkProtocol_Datum #-}
mkProtocol_Datum ::
        [T.WalletPaymentPKH]
    -> LedgerApiV2.CurrencySymbol
    -> Integer
    -> ValidatorDatum
mkProtocol_Datum
    admins
    tokenAdminPolicy_CS
    minADA =
        ProtocolDatum
            $ mkProtocol_DatumType
                    admins
                    tokenAdminPolicy_CS
                    minADA

mkDatum :: ProtocolDatumType -> LedgerApiV2.Datum
mkDatum = LedgerApiV2.Datum . LedgerApiV2.toBuiltinData . ProtocolDatum

--------------------------------------------------------------------------------2
-- ValidatorRedeemer
--------------------------------------------------------------------------------2

data ValidatorRedeemerDatumUpdateType = ValidatorRedeemerDatumUpdateType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerDatumUpdateType where
    {-# INLINABLE (==) #-}
    r1 == r2 =  r1 ==  r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerDatumUpdateType
    [('ValidatorRedeemerDatumUpdateType, 0)]

--------------------------------------------------------------------------------2

data ValidatorRedeemerUpdateMinADAType = ValidatorRedeemerUpdateMinADAType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerUpdateMinADAType where
    {-# INLINABLE (==) #-}
    r1 == r2 =  r1 ==  r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerUpdateMinADAType
    [('ValidatorRedeemerUpdateMinADAType, 0)]

--------------------------------------------------------------------------------2

data ValidatorRedeemerEmergencyType = ValidatorRedeemerEmergencyType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerEmergencyType where
    {-# INLINABLE (==) #-}
    r1 == r2 =  r1 ==  r2

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemerEmergencyType
    [('ValidatorRedeemerEmergencyType, 0)]

--------------------------------------------------------------------------------2
data ValidatorRedeemer
    = ValidatorRedeemerDatumUpdate ValidatorRedeemerDatumUpdateType
    | ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType
    | ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemer where
    {-# INLINABLE (==) #-}
    (==) :: ValidatorRedeemer -> ValidatorRedeemer -> Bool
    ValidatorRedeemerDatumUpdate rmf1 == ValidatorRedeemerDatumUpdate rmf2 =
        rmf1 == rmf2
    ValidatorRedeemerUpdateMinADA rmf1 == ValidatorRedeemerUpdateMinADA rmf2 =
        rmf1 == rmf2
    ValidatorRedeemerEmergency rmf1 == ValidatorRedeemerEmergency rmf2 =
        rmf1 == rmf2
    _ == _ = False

PlutusTx.makeIsDataIndexed
    ''ValidatorRedeemer
        [ ('ValidatorRedeemerDatumUpdate, 0)
        , ('ValidatorRedeemerUpdateMinADA, 1)
        , ('ValidatorRedeemerEmergency, 2)
        ]

--------------------------------------------------------------------------------2


getValidatorRedeemerName :: Maybe ValidatorRedeemer -> Maybe P.String
getValidatorRedeemerName (Just (ValidatorRedeemerDatumUpdate ValidatorRedeemerDatumUpdateType))   = Just "DatumUpdate"
getValidatorRedeemerName (Just (ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType)) = Just "UpdateMinADA"
getValidatorRedeemerName (Just (ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType))       = Just "Emergency"
getValidatorRedeemerName _                                                                        = Nothing

--------------------------------------------------------------------------------2

mkMintIDRedeemer :: LedgerApiV2.Redeemer
mkMintIDRedeemer = LedgerApiV2.Redeemer $ LedgerApiV2.toBuiltinData (0 :: Integer)

mkDatumUpdateRedeemer :: LedgerApiV2.Redeemer
mkDatumUpdateRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerDatumUpdate ValidatorRedeemerDatumUpdateType

mkUpdateMinADARedeemer :: LedgerApiV2.Redeemer
mkUpdateMinADARedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerUpdateMinADA ValidatorRedeemerUpdateMinADAType

mkEmergencyRedeemer :: LedgerApiV2.Redeemer
mkEmergencyRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            ValidatorRedeemerEmergency ValidatorRedeemerEmergencyType

--------------------------------------------------------------------------------2

====== Script/OnChain.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Script.OnChain where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Ledger.Value              as LedgerValue
import qualified Plutonomy
import qualified Plutus.V2.Ledger.Api      as LedgerApiV2
import qualified Plutus.V2.Ledger.Contexts as LedgerContextsV2
import qualified PlutusTx
import           PlutusTx.Prelude

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Constants                 as T
import qualified Helpers.OnChain           as OnChainHelpers
import qualified Helpers.Types             as T
import qualified Protocol.Types            as ProtocolT
import qualified Script.Types              as T
import qualified Types                     as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

{-# INLINEABLE mkPolicyID #-}
mkPolicyID :: T.PolicyParams -> BuiltinData -> BuiltinData -> ()
mkPolicyID  (T.PolicyParams !protocolPolicyID_CS) !redRaw !ctxRaw =
    let
        ------------------
        !useThisToMakeScriptUnique = protocolPolicyID_CS /= LedgerApiV2.adaSymbol
        ------------------
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.PolicyRedeemer redRaw
        !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
    in  if traceIfFalse "" useThisToMakeScriptUnique
            &&  case redeemer of
                T.PolicyRedeemerMintID _ ->
                        ---------------------
                        -- it runs alone
                        ---------------------
                        traceIfFalse "not isCorrectMint_And_Outputs" isCorrectMint_And_Outputs
                        ------------------
                    where
                        isCorrectMint_And_Outputs :: Bool
                        !isCorrectMint_And_Outputs =
                            let !flattenValueOf_Script_IDs = OnChainHelpers.getUnsafeOwnMintingTokenNameAndAmt ctx
                                !cs = LedgerContextsV2.ownCurrencySymbol ctx
                                ------------------
                                !outputs_txOuts = LedgerApiV2.txInfoOutputs info
                                !outputs_TxOuts_And_ScriptDatum = OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_CS
                                    @T.ValidatorDatum
                                    @T.ScriptDatumType
                                    ctx
                                    outputs_txOuts
                                    cs
                                    T.getScriptDatumType
                                ------------------
                                isCorrectAmt_And_TN :: (LedgerApiV2.TokenName, Integer) -> (LedgerContextsV2.TxOut, T.ScriptDatumType) -> Bool
                                isCorrectAmt_And_TN (!tn, !amt) (!txOut, !dat) =
                                    amt == 1 &&
                                    isCorrectTN tn txOut &&
                                    traceIfFalse "not isCorrect_Output_ScriptDatum" (isCorrect_Output_ScriptDatum tn (txOut, dat))
                                ------------------
                                isCorrectTN :: LedgerApiV2.TokenName -> LedgerApiV2.TxOut -> Bool
                                isCorrectTN tn txOut = LedgerApiV2.getScriptHash (OnChainHelpers.fromJust $ LedgerApiV2.txOutReferenceScript txOut) == LedgerApiV2.unTokenName tn
                                 ------------------
                                isCorrect_Output_ScriptDatum :: LedgerApiV2.TokenName -> (LedgerContextsV2.TxOut, T.ScriptDatumType) -> Bool
                                isCorrect_Output_ScriptDatum tn txOut =
                                    let !scriptDatum_Out = OnChainHelpers.getDatum_In_TxOut_And_Datum txOut
                                        !scriptDatum_Out_Control = scriptDatum_Out { T.sdScriptHash = LedgerApiV2.unTokenName tn }
                                    in  scriptDatum_Out `OnChainHelpers.isUnsafeEqDatums` scriptDatum_Out_Control
                                ------------------
                            in  OnChainHelpers.compareWithFunctionWhileRemoving flattenValueOf_Script_IDs outputs_TxOuts_And_ScriptDatum isCorrectAmt_And_TN
                            ------------------
                T.PolicyRedeemerBurnID _ ->
                       ------------------
                        -- it runs along with Script Validator (ValidatorRedeemerDelete)
                            -- traceIfFalse "not isSignedByAdmin nor isAdminTokenPresent" isSignedByAdminOrIsAdminTokenPresent
                            -- && traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange info T.validTxTimeRange)
                            -- && traceIfFalse "not isBurning_ScriptIDs" isBurning_ScriptIDs
                            -- && traceIfFalse "not isCorrectAmount_SendBackToAdmin" isCorrectAmount_SendBackToAdmin
                        ------------------
                        -- la policy permite quemar todos los tokens de la policy
                        -- se sobre entiende que esos tokens estan en utxo en el validador de scripts y que alli se ejecutará la lógica adicional
                        ------------------
                        traceIfFalse "not isBurningAllTokenOwnCSAnyAmount" (OnChainHelpers.isBurningAllTokenOwnCSAnyAmount ctx)
                        ------------------
            then ()
            else error ()

--------------------------------------------------------------------------------2

{-# INLINEABLE mkValidator #-}
mkValidator :: T.ValidatorParams -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkValidator (T.ValidatorParams !scriptPolicyID_CS !protocolPolicyID_CS)  _ !redRaw !ctxRaw =
    let
        ------------------
        !useThisToMakeScriptUnique = protocolPolicyID_CS /= LedgerApiV2.adaSymbol
        ------------------
        !redeemer = LedgerApiV2.unsafeFromBuiltinData @T.ValidatorRedeemer redRaw
        !ctx = LedgerApiV2.unsafeFromBuiltinData @LedgerContextsV2.ScriptContext ctxRaw
        !info = LedgerContextsV2.scriptContextTxInfo ctx
        ------------------
        !input_TxOut_BeingValidated = OnChainHelpers.getUnsafe_Own_Input_TxOut ctx
        !script_Validator_Address = LedgerApiV2.txOutAddress input_TxOut_BeingValidated
        ------------------
    in  if
        traceIfFalse "" useThisToMakeScriptUnique
        && case redeemer of
            T.ValidatorRedeemerDelete ->
                    ------------------
                    -- it runs along with Script ID Policy (PolicyRedeemerBurnID)
                        -- traceIfFalse "not isBurningAllTokenOwnCSAnyAmount" (OnChainHelpers.isBurningAllTokenOwnCSAnyAmount ctx)
                    ------------------
                       traceIfFalse "not isSignedByAdmin nor isAdminTokenPresent" isSignedByAdminOrIsAdminTokenPresent
                    && traceIfFalse "not isValidRange" (OnChainHelpers.isValidRange info T.validTxTimeRange)
                    && traceIfFalse "not isBurning_ScriptIDs" isBurning_ScriptIDs
                    && traceIfFalse "not isCorrectAmount_SendBackToAdmin" isCorrectAmount_SendBackToAdmin
                where
                    ------------------
                    !inputsRef_TxOuts = [LedgerApiV2.txInInfoResolved txInfoInput | txInfoInput <- LedgerApiV2.txInfoReferenceInputs info,
                        OnChainHelpers.isScriptAddress (LedgerApiV2.txOutAddress $ LedgerApiV2.txInInfoResolved txInfoInput )]
                    ------------------
                    !inputs_Own_TxOuts = [LedgerApiV2.txInInfoResolved txInfoInput | txInfoInput <- LedgerApiV2.txInfoInputs info,
                                    let address = LedgerApiV2.txOutAddress (LedgerApiV2.txInInfoResolved txInfoInput)
                                    in  OnChainHelpers.isScriptAddress address && address == script_Validator_Address]
                    ------------------
                    !inputs_Own_TxOuts_And_ScriptDatums = OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_CS
                        @T.ValidatorDatum @T.ScriptDatumType
                        ctx
                        inputs_Own_TxOuts
                        scriptPolicyID_CS
                        T.getScriptDatumType
                    ------------------
                    !scriptDatums_In = OnChainHelpers.getDatum_In_TxOut_And_Datum <$> inputs_Own_TxOuts_And_ScriptDatums
                    ------------------
                    isSignedByAdminOrIsAdminTokenPresent :: Bool
                    !isSignedByAdminOrIsAdminTokenPresent =
                        let
                            !protocolID_AC = LedgerValue.AssetClass (protocolPolicyID_CS, T.protocolID_TN)

                            !inputRef_TxOut_And_ProtocolDatum' = OnChainHelpers.getTxOuts_And_DatumTypes_From_TxOuts_By_AC
                                @ProtocolT.ValidatorDatum
                                @ProtocolT.ProtocolDatumType
                                ctx
                                inputsRef_TxOuts
                                protocolID_AC
                                ProtocolT.getProtocol_DatumType

                            !protocolDatum_In = case inputRef_TxOut_And_ProtocolDatum' of
                                [inputRef_TxOut_And_ProtocolDatum] -> OnChainHelpers.getDatum_In_TxOut_And_Datum inputRef_TxOut_And_ProtocolDatum
                                _                                  -> traceError "Expected exactly Protocol input ref"

                            !tokenAdminPolicy_CS = T.getAdminToken_CS protocolDatum_In
                            !tokenAdmin_AC = LedgerValue.AssetClass (tokenAdminPolicy_CS, T.tokenAdmin_TN)

                            !isAdminTokenPresent = OnChainHelpers.isToken_With_AC_InValue (LedgerApiV2.txOutValue $ head (LedgerApiV2.txInfoOutputs info)) tokenAdmin_AC

                            isSignedByEachAdmin scriptDatum_In =
                                let !admin = T.sdAdminPaymentPKH scriptDatum_In
                                in LedgerContextsV2.txSignedBy info admin

                        in (isAdminTokenPresent || all isSignedByEachAdmin scriptDatums_In)
                    ------------------
                    isBurning_ScriptIDs :: Bool
                    !isBurning_ScriptIDs =
                        let !valueOf_Inputs_Own_TxOuts_And_ScriptDatums = mconcat $ OnChainHelpers.getValue_In_TxOut_And_Datum <$> inputs_Own_TxOuts_And_ScriptDatums
                        ------------------
                            !flattenValueOf_Script_IDs = OnChainHelpers.flattenValue $ LedgerValue.noAdaValue valueOf_Inputs_Own_TxOuts_And_ScriptDatums
                        in  all
                                ( \(cs, tn, amt) ->
                                    let scriptID_AC = LedgerValue.AssetClass (cs, tn)
                                    in  OnChainHelpers.isToken_Minting_With_AC_AndAmt scriptID_AC (negate amt) info
                                )
                                flattenValueOf_Script_IDs
                    ------------------
                    isCorrectAmount_SendBackToAdmin :: Bool
                    !isCorrectAmount_SendBackToAdmin =
                        let joinSameAdmin :: [(T.WalletPaymentPKH, LedgerApiV2.Value)] -> [(T.WalletPaymentPKH, LedgerApiV2.Value, LedgerApiV2.Value)]
                            joinSameAdmin = joinSameAdminHelper []
                                where
                                    joinSameAdminHelper :: [(T.WalletPaymentPKH, LedgerApiV2.Value, LedgerApiV2.Value)] -> [(T.WalletPaymentPKH, LedgerApiV2.Value)] -> [(T.WalletPaymentPKH, LedgerApiV2.Value, LedgerApiV2.Value)]
                                    joinSameAdminHelper seen [] = seen
                                    joinSameAdminHelper seen ((admin_To_SendBack, valueOf_ScriptDatum) : xs) =
                                        let !admin' = OnChainHelpers.find' (\(m, _, _) -> m == admin_To_SendBack) seen
                                        in  case admin' of
                                                Nothing ->
                                                    let !valueFor_Admin_Real = LedgerContextsV2.valuePaidTo info admin_To_SendBack
                                                        !elemet = (admin_To_SendBack, valueOf_ScriptDatum, valueFor_Admin_Real)
                                                    in  joinSameAdminHelper (elemet : seen) xs
                                                Just (_, v1, v2) ->
                                                    let !elemet = (admin_To_SendBack, v1 <> valueOf_ScriptDatum, v2)
                                                        !seen_filter = OnChainHelpers.filter' (\(m', _, _) -> m' /= admin_To_SendBack) seen
                                                    in  joinSameAdminHelper (elemet : seen_filter) xs
                            ------------------
                            !values_For_Each_Admin =
                                [ let !scriptDatum_In = OnChainHelpers.getDatum_In_TxOut_And_Datum input_Own_TxOut_And_ScriptDatum
                                      !admin_To_SendBack = T.sdAdminPaymentPKH scriptDatum_In
                                      !valueFor_Admin = LedgerValue.adaOnlyValue $ OnChainHelpers.getValue_In_TxOut_And_Datum input_Own_TxOut_And_ScriptDatum
                                  in  (admin_To_SendBack, valueFor_Admin)
                                  | input_Own_TxOut_And_ScriptDatum <- inputs_Own_TxOuts_And_ScriptDatums
                                ]
                            ------------------
                            !values_For_Each_Admin_Accumulated = joinSameAdmin values_For_Each_Admin
                        in  all (\(_, v1, v2) -> OnChainHelpers.isIncludeValue' v2 v1) values_For_Each_Admin_Accumulated
            then ()
            else error ()

----------------------------------------------------------------------------

{-# INLINEABLE policyID #-}
policyID :: T.PolicyParams -> LedgerApiV2.MintingPolicy
policyID params =
    Plutonomy.optimizeUPLC $
        Plutonomy.mintingPolicyToPlutus $
            Plutonomy.mkMintingPolicyScript $
                $$(PlutusTx.compile [||mkPolicyID||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params


{-# INLINABLE  mkWrappedPolicyID #-}
mkWrappedPolicyID :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedPolicyID protocolPolicyID_CS   = mkPolicyID params
    where
        params = T.PolicyParams
            {
                ppProtocolPolicyID_CS   =PlutusTx.unsafeFromBuiltinData protocolPolicyID_CS
            }

policyIDCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())
policyIDCode = Plutonomy.optimizeUPLC $$( PlutusTx.compile [|| mkWrappedPolicyID ||])

----------------------------------------------------------------------------

{-# INLINEABLE validator #-}
validator :: T.ValidatorParams -> LedgerApiV2.Validator
validator params =
    Plutonomy.optimizeUPLC $
        Plutonomy.validatorToPlutus $
            Plutonomy.mkValidatorScript $
                $$(PlutusTx.compile [||mkValidator||])
                    `PlutusTx.applyCode` PlutusTx.liftCode params

{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData ->  BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator protocolPolicyID_CS scriptPolicyID_CS = mkValidator params
    where
        params = T.ValidatorParams
            {
            vpProtocolPolicyID_CS  = PlutusTx.unsafeFromBuiltinData protocolPolicyID_CS,
            vpScriptPolicyID_CS    = PlutusTx.unsafeFromBuiltinData scriptPolicyID_CS
            }

validatorCode :: PlutusTx.CompiledCode ( BuiltinData -> BuiltinData ->  BuiltinData -> BuiltinData -> BuiltinData -> ())
validatorCode = Plutonomy.optimizeUPLC $$( PlutusTx.compile [|| mkWrappedValidator ||])

------------------------------------------------------------------------------

====== Script/Types.hs ======

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeSynonymInstances  #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Script.Types where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Data.Aeson           as DataAeson
import qualified Data.OpenApi.Schema  as DataOpenApiSchema
import qualified GHC.Generics         as GHCGenerics
import qualified Ledger.Value         as LedgerValue
import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import qualified PlutusTx
import           PlutusTx.Prelude
import qualified Prelude              as P
import qualified Schema

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Constants            as T
import qualified Helpers.Types        as T
import qualified Protocol.Types       as ProtocolT
import qualified Types                as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

-- Any change in the logic, datum or redeemer must change the version of the scriptVersion
scriptVersion :: Integer
scriptVersion = 1

ownVersion :: Integer
ownVersion = T.mkVersionWithDependency [ProtocolT.protocolVersion] scriptVersion

--------------------------------------------------------------------------------2
-- Params
--------------------------------------------------------------------------------2

newtype PolicyParams
    = PolicyParams { ppProtocolPolicyID_CS :: T.CS }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

instance Eq PolicyParams where
    {-# INLINEABLE (==) #-}
    p1 == p2 = ppProtocolPolicyID_CS p1 == ppProtocolPolicyID_CS p2

PlutusTx.makeLift ''PolicyParams
PlutusTx.makeIsDataIndexed ''PolicyParams [('PolicyParams, 0)]

data ValidatorParams
    = ValidatorParams
          { vpProtocolPolicyID_CS :: T.CS
          , vpScriptPolicyID_CS   :: T.CS
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, DataOpenApiSchema.ToSchema, GHCGenerics.Generic, P.Eq, P.Ord, P.Show, Schema.ToSchema)

instance Eq ValidatorParams where
    {-# INLINEABLE (==) #-}
    p1 == p2 =
        vpProtocolPolicyID_CS p1 == vpProtocolPolicyID_CS p2  &&
        vpScriptPolicyID_CS p1 == vpScriptPolicyID_CS p2

PlutusTx.makeLift ''ValidatorParams
PlutusTx.makeIsDataIndexed ''ValidatorParams [('ValidatorParams, 0)]

--------------------------------------------------------------------------------2
-- Datums
--------------------------------------------------------------------------------2

data ScriptDatumType
    = ScriptDatumType
          { sdVersion         :: Integer
          , sdAdminPaymentPKH :: T.WalletPaymentPKH
          , sdAdminStakePKH   :: Maybe T.WalletPaymentPKH
          , sdScriptHash      :: BuiltinByteString
          }
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq ScriptDatumType where
    {-# INLINEABLE (==) #-}
    sd1 == sd2 =
        sdVersion sd1 == sdVersion sd2
            && sdAdminPaymentPKH sd1 == sdAdminPaymentPKH sd2
            && sdAdminStakePKH sd1 == sdAdminStakePKH sd2
            && sdScriptHash sd1 == sdScriptHash sd2

PlutusTx.makeIsDataIndexed ''ScriptDatumType [('ScriptDatumType, 0)]

newtype ValidatorDatum
    = ScriptDatum ScriptDatumType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Eq, P.Ord, P.Show)

instance Eq ValidatorDatum where
    {-# INLINEABLE (==) #-}
    ScriptDatum sd1 == ScriptDatum sd2 = sd1 == sd2

PlutusTx.makeIsDataIndexed ''ValidatorDatum [('ScriptDatum, 0)]

{-# INLINEABLE getScriptDatumType #-}
getScriptDatumType :: ValidatorDatum -> ScriptDatumType
getScriptDatumType (ScriptDatum sdType) = sdType

instance T.ShowDatum ValidatorDatum where
    showCborAsDatumType cbor = case LedgerApiV2.fromBuiltinData @ValidatorDatum cbor of
        Nothing -> Nothing
        Just d  -> Just $ P.show d

--------------------------------------------------------------------------------2

{-# INLINEABLE mkScriptDatumType #-}
mkScriptDatumType ::T.WalletPaymentPKH -> Maybe T.WalletPaymentPKH -> BuiltinByteString -> ScriptDatumType
mkScriptDatumType = ScriptDatumType ownVersion

{-# INLINEABLE mkScriptDatum #-}
mkScriptDatum :: T.WalletPaymentPKH -> Maybe T.WalletPaymentPKH -> BuiltinByteString -> ValidatorDatum
mkScriptDatum
    adminPaymentPKH
    adminStakePKH
    scriptHash =
        ScriptDatum $
            mkScriptDatumType
                adminPaymentPKH
                adminStakePKH
                scriptHash

mkDatum :: ScriptDatumType -> LedgerApiV2.Datum
mkDatum = LedgerApiV2.Datum . LedgerApiV2.toBuiltinData . ScriptDatum

--------------------------------------------------------------------------------2
-- PolicyRedeemer
--------------------------------------------------------------------------------2

data PolicyRedeemerMintIDType = PolicyRedeemerMintIDType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerMintIDType where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.unstableMakeIsData ''PolicyRedeemerMintIDType

data PolicyRedeemerBurnIDType = PolicyRedeemerBurnIDType deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemerBurnIDType where
    {-# INLINEABLE (==) #-}
    r1 == r2 =
        r1 == r2

PlutusTx.unstableMakeIsData ''PolicyRedeemerBurnIDType

data PolicyRedeemer
    = PolicyRedeemerMintID PolicyRedeemerMintIDType
    | PolicyRedeemerBurnID PolicyRedeemerBurnIDType
    deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq PolicyRedeemer where
    {-# INLINEABLE (==) #-}
    PolicyRedeemerMintID rmtx1 == PolicyRedeemerMintID rmtx2 = rmtx1 == rmtx2
    PolicyRedeemerBurnID rmtx1 == PolicyRedeemerBurnID rmtx2 = rmtx1 == rmtx2
    _ == _                                                   = False

PlutusTx.makeIsDataIndexed
    ''PolicyRedeemer
    [ ('PolicyRedeemerMintID, 1),
      ('PolicyRedeemerBurnID, 2)
    ]

--------------------------------------------------------------------------------2

getPolicyRedeemerName :: Maybe PolicyRedeemer -> Maybe P.String
getPolicyRedeemerName (Just (PolicyRedeemerMintID PolicyRedeemerMintIDType)) = Just "MintID"
getPolicyRedeemerName (Just (PolicyRedeemerBurnID PolicyRedeemerBurnIDType)) = Just "BurnID"
getPolicyRedeemerName _                                                      = Nothing


--------------------------------------------------------------------------------2
-- ValidatorRedeemer
--------------------------------------------------------------------------------2

data ValidatorRedeemerDelete = ValidatorRedeemerDelete deriving (DataAeson.FromJSON, DataAeson.ToJSON, GHCGenerics.Generic, P.Show)

instance Eq ValidatorRedeemerDelete where
    {-# INLINEABLE (==) #-}
    r1 == r2 = r1 == r2

PlutusTx.makeIsDataIndexed ''ValidatorRedeemerDelete [('ValidatorRedeemerDelete, 0)]

type ValidatorRedeemer = ValidatorRedeemerDelete

------------------------------------------------------------------------------

getValidatorRedeemerName :: Maybe ValidatorRedeemer -> Maybe P.String
getValidatorRedeemerName (Just ValidatorRedeemerDelete) = Just "Delete"
getValidatorRedeemerName _                              = Nothing

------------------------------------------------------------------------------

mkMintIDRedeemer :: LedgerApiV2.Redeemer
mkMintIDRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerMintID PolicyRedeemerMintIDType

mkBurnIDRedeemer :: LedgerApiV2.Redeemer
mkBurnIDRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData $
            PolicyRedeemerBurnID PolicyRedeemerBurnIDType

--------------------------------------------------------------------------------2

mkScriptDeleteRedeemer :: LedgerApiV2.Redeemer
mkScriptDeleteRedeemer =
    LedgerApiV2.Redeemer $
        LedgerApiV2.toBuiltinData
            ValidatorRedeemerDelete

--------------------------------------------------------------------------------2

====== Types.hs ======

{-# LANGUAGE AllowAmbiguousTypes   #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DerivingStrategies    #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TypeFamilies          #-}

--------------------------------------------------------------------------------2
{- HLINT ignore "Use camelCase"          -}
--------------------------------------------------------------------------------2

module Types where

--------------------------------------------------------------------------------2
-- Import Externos
--------------------------------------------------------------------------------2

import qualified Plutus.V2.Ledger.Api as LedgerApiV2
import           PlutusTx.Prelude     hiding (unless)
import qualified Prelude              as P

--------------------------------------------------------------------------------2
-- Import Internos
--------------------------------------------------------------------------------2

import qualified Helpers.Types        as T

--------------------------------------------------------------------------------2
-- Modulo
--------------------------------------------------------------------------------2

class HasAdmins a where
    getAdmins :: a -> [T.WalletPaymentPKH]

class HasAdminToken a where
    getAdminToken_CS :: a -> LedgerApiV2.CurrencySymbol

class ShowDatum datum where
    showCborAsDatumType :: BuiltinData -> Maybe P.String

--------------------------------------------------------------------------------2
